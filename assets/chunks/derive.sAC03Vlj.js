const ut=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Fe(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function Vt(e){if(!Number.isSafeInteger(e)||e<0)throw new Error("positive integer expected, got "+e)}function Bt(e,...n){if(!Fe(e))throw new Error("Uint8Array expected");if(n.length>0&&!n.includes(e.length))throw new Error("Uint8Array expected of length "+n+", got length="+e.length)}function Pe(e){if(typeof e!="function"||typeof e.create!="function")throw new Error("Hash should be wrapped by utils.createHasher");Vt(e.outputLen),Vt(e.blockLen)}function Nt(e,n=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(n&&e.finished)throw new Error("Hash#digest() has already been called")}function ze(e,n){Bt(e);const t=n.outputLen;if(e.length<t)throw new Error("digestInto() expects output buffer of length at least "+t)}function gt(...e){for(let n=0;n<e.length;n++)e[n].fill(0)}function Ft(e){return new DataView(e.buffer,e.byteOffset,e.byteLength)}function Y(e,n){return e<<32-n|e>>>n}function Te(e){if(typeof e!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(e))}function Yt(e){return typeof e=="string"&&(e=Te(e)),Bt(e),e}function De(...e){let n=0;for(let r=0;r<e.length;r++){const i=e[r];Bt(i),n+=i.length}const t=new Uint8Array(n);for(let r=0,i=0;r<e.length;r++){const f=e[r];t.set(f,i),i+=f.length}return t}class ge{}function $t(e){const n=r=>e().update(Yt(r)).digest(),t=e();return n.outputLen=t.outputLen,n.blockLen=t.blockLen,n.create=()=>e(),n}function ke(e=32){if(ut&&typeof ut.getRandomValues=="function")return ut.getRandomValues(new Uint8Array(e));if(ut&&typeof ut.randomBytes=="function")return Uint8Array.from(ut.randomBytes(e));throw new Error("crypto.getRandomValues must be defined")}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Qt=BigInt(0),Gt=BigInt(1);function pt(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function _t(e){if(!pt(e))throw new Error("Uint8Array expected")}function mt(e,n){if(typeof n!="boolean")throw new Error(e+" boolean expected, got "+n)}function At(e){const n=e.toString(16);return n.length&1?"0"+n:n}function pe(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);return e===""?Qt:BigInt("0x"+e)}const we=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",Ze=Array.from({length:256},(e,n)=>n.toString(16).padStart(2,"0"));function Et(e){if(_t(e),we)return e.toHex();let n="";for(let t=0;t<e.length;t++)n+=Ze[e[t]];return n}const $={_0:48,_9:57,A:65,F:70,a:97,f:102};function ee(e){if(e>=$._0&&e<=$._9)return e-$._0;if(e>=$.A&&e<=$.F)return e-($.A-10);if(e>=$.a&&e<=$.f)return e-($.a-10)}function Ht(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);if(we)return Uint8Array.fromHex(e);const n=e.length,t=n/2;if(n%2)throw new Error("hex string expected, got unpadded hex of length "+n);const r=new Uint8Array(t);for(let i=0,f=0;i<t;i++,f+=2){const o=ee(e.charCodeAt(f)),a=ee(e.charCodeAt(f+1));if(o===void 0||a===void 0){const s=e[f]+e[f+1];throw new Error('hex string expected, got non-hex character "'+s+'" at index '+f)}r[i]=o*16+a}return r}function at(e){return pe(Et(e))}function ye(e){return _t(e),pe(Et(Uint8Array.from(e).reverse()))}function xt(e,n){return Ht(e.toString(16).padStart(n*2,"0"))}function me(e,n){return xt(e,n).reverse()}function M(e,n,t){let r;if(typeof n=="string")try{r=Ht(n)}catch(f){throw new Error(e+" must be hex string or Uint8Array, cause: "+f)}else if(pt(n))r=Uint8Array.from(n);else throw new Error(e+" must be hex string or Uint8Array");const i=r.length;if(typeof t=="number"&&i!==t)throw new Error(e+" of length "+t+" expected, got "+i);return r}function Ut(...e){let n=0;for(let r=0;r<e.length;r++){const i=e[r];_t(i),n+=i.length}const t=new Uint8Array(n);for(let r=0,i=0;r<e.length;r++){const f=e[r];t.set(f,i),i+=f.length}return t}const Pt=e=>typeof e=="bigint"&&Qt<=e;function Jt(e,n,t){return Pt(e)&&Pt(n)&&Pt(t)&&n<=e&&e<t}function bt(e,n,t,r){if(!Jt(n,t,r))throw new Error("expected valid "+e+": "+t+" <= n < "+r+", got "+n)}function Ve(e){let n;for(n=0;e>Qt;e>>=Gt,n+=1);return n}const Rt=e=>(Gt<<BigInt(e))-Gt,zt=e=>new Uint8Array(e),ne=e=>Uint8Array.from(e);function Ge(e,n,t){if(typeof e!="number"||e<2)throw new Error("hashLen must be a number");if(typeof n!="number"||n<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");let r=zt(e),i=zt(e),f=0;const o=()=>{r.fill(1),i.fill(0),f=0},a=(...p)=>t(i,r,...p),s=(p=zt(0))=>{i=a(ne([0]),p),r=a(),p.length!==0&&(i=a(ne([1]),p),r=a())},u=()=>{if(f++>=1e3)throw new Error("drbg: tried 1000 values");let p=0;const h=[];for(;p<n;){r=a();const l=r.slice();h.push(l),p+=r.length}return Ut(...h)};return(p,h)=>{o(),s(p);let l;for(;!(l=h(u()));)s();return o(),l}}const Ke={bigint:e=>typeof e=="bigint",function:e=>typeof e=="function",boolean:e=>typeof e=="boolean",string:e=>typeof e=="string",stringOrUint8Array:e=>typeof e=="string"||pt(e),isSafeInteger:e=>Number.isSafeInteger(e),array:e=>Array.isArray(e),field:(e,n)=>n.Fp.isValid(e),hash:e=>typeof e=="function"&&Number.isSafeInteger(e.outputLen)};function Lt(e,n,t={}){const r=(i,f,o)=>{const a=Ke[f];if(typeof a!="function")throw new Error("invalid validator function");const s=e[i];if(!(o&&s===void 0)&&!a(s,e))throw new Error("param "+String(i)+" is invalid. Expected "+f+", got "+s)};for(const[i,f]of Object.entries(n))r(i,f,!1);for(const[i,f]of Object.entries(t))r(i,f,!0);return e}function re(e){const n=new WeakMap;return(t,...r)=>{const i=n.get(t);if(i!==void 0)return i;const f=e(t,...r);return n.set(t,f),f}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const V=BigInt(0),D=BigInt(1),st=BigInt(2),je=BigInt(3),Kt=BigInt(4),ie=BigInt(5),oe=BigInt(8);function K(e,n){const t=e%n;return t>=V?t:n+t}function jt(e,n){if(e===V)throw new Error("invert: expected non-zero number");if(n<=V)throw new Error("invert: expected positive modulus, got "+n);let t=K(e,n),r=n,i=V,f=D;for(;t!==V;){const o=r/t,a=r%t,s=i-f*o;r=t,t=a,i=f,f=s}if(r!==D)throw new Error("invert: does not exist");return K(i,n)}function Me(e){let n=e-D,t=0;for(;n%st===V;)n/=st,t++;let r=st;const i=vt(e);for(;r<e&&fe(i,r);)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(t===1){const o=(e+D)/Kt;return function(a,s){const u=a.pow(s,o);if(!a.eql(a.sqr(u),s))throw new Error("Cannot find square root");return u}}const f=(n+D)/st;return function(o,a){if(!fe(o,a))throw new Error("Cannot find square root");let s=t,u=o.pow(o.mul(o.ONE,r),n),p=o.pow(a,f),h=o.pow(a,n);for(;!o.eql(h,o.ONE);){if(o.eql(h,o.ZERO))return o.ZERO;let l=1;for(let I=o.sqr(h);l<s&&!o.eql(I,o.ONE);l++)I=o.sqr(I);const B=o.pow(u,D<<BigInt(s-l-1));u=o.sqr(B),p=o.mul(p,B),h=o.mul(h,u),s=l}return p}}function We(e){return e%Kt===je?function(n,t){const r=(e+D)/Kt,i=n.pow(t,r);if(!n.eql(n.sqr(i),t))throw new Error("Cannot find square root");return i}:e%oe===ie?function(n,t){const r=n.mul(t,st),i=(e-ie)/oe,f=n.pow(r,i),o=n.mul(t,f),a=n.mul(n.mul(o,st),f),s=n.mul(o,n.sub(a,n.ONE));if(!n.eql(n.sqr(s),t))throw new Error("Cannot find square root");return s}:Me(e)}const Ye=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function $e(e){const n={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=Ye.reduce((r,i)=>(r[i]="function",r),n);return Lt(e,t)}function Qe(e,n,t){if(t<V)throw new Error("invalid exponent, negatives unsupported");if(t===V)return e.ONE;if(t===D)return n;let r=e.ONE,i=n;for(;t>V;)t&D&&(r=e.mul(r,i)),i=e.sqr(i),t>>=D;return r}function Ee(e,n,t=!1){const r=new Array(n.length).fill(t?e.ZERO:void 0),i=n.reduce((o,a,s)=>e.is0(a)?o:(r[s]=o,e.mul(o,a)),e.ONE),f=e.inv(i);return n.reduceRight((o,a,s)=>e.is0(a)?o:(r[s]=e.mul(o,r[s]),e.mul(o,a)),f),r}function _e(e,n){const t=(e.ORDER-D)/st,r=e.pow(n,t),i=e.eql(r,e.ONE),f=e.eql(r,e.ZERO),o=e.eql(r,e.neg(e.ONE));if(!i&&!f&&!o)throw new Error("Cannot find square root: probably non-prime P");return i?1:f?0:-1}function fe(e,n){const t=_e(e,n);return t===0||t===1}function xe(e,n){n!==void 0&&Vt(n);const t=n!==void 0?n:e.toString(2).length,r=Math.ceil(t/8);return{nBitLength:t,nByteLength:r}}function vt(e,n,t=!1,r={}){if(e<=V)throw new Error("invalid field: expected ORDER > 0, got "+e);const{nBitLength:i,nByteLength:f}=xe(e,n);if(f>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let o;const a=Object.freeze({ORDER:e,isLE:t,BITS:i,BYTES:f,MASK:Rt(i),ZERO:V,ONE:D,create:s=>K(s,e),isValid:s=>{if(typeof s!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof s);return V<=s&&s<e},is0:s=>s===V,isOdd:s=>(s&D)===D,neg:s=>K(-s,e),eql:(s,u)=>s===u,sqr:s=>K(s*s,e),add:(s,u)=>K(s+u,e),sub:(s,u)=>K(s-u,e),mul:(s,u)=>K(s*u,e),pow:(s,u)=>Qe(a,s,u),div:(s,u)=>K(s*jt(u,e),e),sqrN:s=>s*s,addN:(s,u)=>s+u,subN:(s,u)=>s-u,mulN:(s,u)=>s*u,inv:s=>jt(s,e),sqrt:r.sqrt||(s=>(o||(o=We(e)),o(a,s))),toBytes:s=>t?me(s,f):xt(s,f),fromBytes:s=>{if(s.length!==f)throw new Error("Field.fromBytes: expected "+f+" bytes, got "+s.length);return t?ye(s):at(s)},invertBatch:s=>Ee(a,s),cmov:(s,u,p)=>p?u:s});return Object.freeze(a)}function Be(e){if(typeof e!="bigint")throw new Error("field order must be bigint");const n=e.toString(2).length;return Math.ceil(n/8)}function ve(e){const n=Be(e);return n+Math.ceil(n/2)}function Je(e,n,t=!1){const r=e.length,i=Be(n),f=ve(n);if(r<16||r<f||r>1024)throw new Error("expected "+f+"-1024 bytes of input, got "+r);const o=t?ye(e):at(e),a=K(o,n-D)+D;return t?me(a,i):xt(a,i)}function Xe(e,n,t,r){if(typeof e.setBigUint64=="function")return e.setBigUint64(n,t,r);const i=BigInt(32),f=BigInt(4294967295),o=Number(t>>i&f),a=Number(t&f),s=r?4:0,u=r?0:4;e.setUint32(n+s,o,r),e.setUint32(n+u,a,r)}function tn(e,n,t){return e&n^~e&t}function en(e,n,t){return e&n^e&t^n&t}class Ae extends ge{constructor(n,t,r,i){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=n,this.outputLen=t,this.padOffset=r,this.isLE=i,this.buffer=new Uint8Array(n),this.view=Ft(this.buffer)}update(n){Nt(this),n=Yt(n),Bt(n);const{view:t,buffer:r,blockLen:i}=this,f=n.length;for(let o=0;o<f;){const a=Math.min(i-this.pos,f-o);if(a===i){const s=Ft(n);for(;i<=f-o;o+=i)this.process(s,o);continue}r.set(n.subarray(o,o+a),this.pos),this.pos+=a,o+=a,this.pos===i&&(this.process(t,0),this.pos=0)}return this.length+=n.length,this.roundClean(),this}digestInto(n){Nt(this),ze(n,this),this.finished=!0;const{buffer:t,view:r,blockLen:i,isLE:f}=this;let{pos:o}=this;t[o++]=128,gt(this.buffer.subarray(o)),this.padOffset>i-o&&(this.process(r,0),o=0);for(let h=o;h<i;h++)t[h]=0;Xe(r,i-8,BigInt(this.length*8),f),this.process(r,0);const a=Ft(n),s=this.outputLen;if(s%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const u=s/4,p=this.get();if(u>p.length)throw new Error("_sha2: outputLen bigger than state");for(let h=0;h<u;h++)a.setUint32(4*h,p[h],f)}digest(){const{buffer:n,outputLen:t}=this;this.digestInto(n);const r=n.slice(0,t);return this.destroy(),r}_cloneInto(n){n||(n=new this.constructor),n.set(...this.get());const{blockLen:t,buffer:r,length:i,finished:f,destroyed:o,pos:a}=this;return n.destroyed=o,n.finished=f,n.length=i,n.pos=a,i%t&&n.buffer.set(r),n}clone(){return this._cloneInto()}}const tt=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),z=Uint32Array.from([3418070365,3238371032,1654270250,914150663,2438529370,812702999,355462360,4144912697,1731405415,4290775857,2394180231,1750603025,3675008525,1694076839,1203062813,3204075428]),T=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),St=BigInt(2**32-1),se=BigInt(32);function nn(e,n=!1){return n?{h:Number(e&St),l:Number(e>>se&St)}:{h:Number(e>>se&St)|0,l:Number(e&St)|0}}function rn(e,n=!1){const t=e.length;let r=new Uint32Array(t),i=new Uint32Array(t);for(let f=0;f<t;f++){const{h:o,l:a}=nn(e[f],n);[r[f],i[f]]=[o,a]}return[r,i]}const ae=(e,n,t)=>e>>>t,ce=(e,n,t)=>e<<32-t|n>>>t,ht=(e,n,t)=>e>>>t|n<<32-t,dt=(e,n,t)=>e<<32-t|n>>>t,It=(e,n,t)=>e<<64-t|n>>>t-32,Ot=(e,n,t)=>e>>>t-32|n<<64-t;function Q(e,n,t,r){const i=(n>>>0)+(r>>>0);return{h:e+t+(i/2**32|0)|0,l:i|0}}const on=(e,n,t)=>(e>>>0)+(n>>>0)+(t>>>0),fn=(e,n,t,r)=>n+t+r+(e/2**32|0)|0,sn=(e,n,t,r)=>(e>>>0)+(n>>>0)+(t>>>0)+(r>>>0),an=(e,n,t,r,i)=>n+t+r+i+(e/2**32|0)|0,cn=(e,n,t,r,i)=>(e>>>0)+(n>>>0)+(t>>>0)+(r>>>0)+(i>>>0),ln=(e,n,t,r,i,f)=>n+t+r+i+f+(e/2**32|0)|0,un=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),et=new Uint32Array(64);class hn extends Ae{constructor(n=32){super(64,n,8,!1),this.A=tt[0]|0,this.B=tt[1]|0,this.C=tt[2]|0,this.D=tt[3]|0,this.E=tt[4]|0,this.F=tt[5]|0,this.G=tt[6]|0,this.H=tt[7]|0}get(){const{A:n,B:t,C:r,D:i,E:f,F:o,G:a,H:s}=this;return[n,t,r,i,f,o,a,s]}set(n,t,r,i,f,o,a,s){this.A=n|0,this.B=t|0,this.C=r|0,this.D=i|0,this.E=f|0,this.F=o|0,this.G=a|0,this.H=s|0}process(n,t){for(let h=0;h<16;h++,t+=4)et[h]=n.getUint32(t,!1);for(let h=16;h<64;h++){const l=et[h-15],B=et[h-2],I=Y(l,7)^Y(l,18)^l>>>3,E=Y(B,17)^Y(B,19)^B>>>10;et[h]=E+et[h-7]+I+et[h-16]|0}let{A:r,B:i,C:f,D:o,E:a,F:s,G:u,H:p}=this;for(let h=0;h<64;h++){const l=Y(a,6)^Y(a,11)^Y(a,25),B=p+l+tn(a,s,u)+un[h]+et[h]|0,I=(Y(r,2)^Y(r,13)^Y(r,22))+en(r,i,f)|0;p=u,u=s,s=a,a=o+B|0,o=f,f=i,i=r,r=B+I|0}r=r+this.A|0,i=i+this.B|0,f=f+this.C|0,o=o+this.D|0,a=a+this.E|0,s=s+this.F|0,u=u+this.G|0,p=p+this.H|0,this.set(r,i,f,o,a,s,u,p)}roundClean(){gt(et)}destroy(){this.set(0,0,0,0,0,0,0,0),gt(this.buffer)}}const Se=rn(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(e=>BigInt(e))),dn=Se[0],bn=Se[1],nt=new Uint32Array(80),rt=new Uint32Array(80);class Ie extends Ae{constructor(n=64){super(128,n,16,!1),this.Ah=T[0]|0,this.Al=T[1]|0,this.Bh=T[2]|0,this.Bl=T[3]|0,this.Ch=T[4]|0,this.Cl=T[5]|0,this.Dh=T[6]|0,this.Dl=T[7]|0,this.Eh=T[8]|0,this.El=T[9]|0,this.Fh=T[10]|0,this.Fl=T[11]|0,this.Gh=T[12]|0,this.Gl=T[13]|0,this.Hh=T[14]|0,this.Hl=T[15]|0}get(){const{Ah:n,Al:t,Bh:r,Bl:i,Ch:f,Cl:o,Dh:a,Dl:s,Eh:u,El:p,Fh:h,Fl:l,Gh:B,Gl:I,Hh:E,Hl:c}=this;return[n,t,r,i,f,o,a,s,u,p,h,l,B,I,E,c]}set(n,t,r,i,f,o,a,s,u,p,h,l,B,I,E,c){this.Ah=n|0,this.Al=t|0,this.Bh=r|0,this.Bl=i|0,this.Ch=f|0,this.Cl=o|0,this.Dh=a|0,this.Dl=s|0,this.Eh=u|0,this.El=p|0,this.Fh=h|0,this.Fl=l|0,this.Gh=B|0,this.Gl=I|0,this.Hh=E|0,this.Hl=c|0}process(n,t){for(let b=0;b<16;b++,t+=4)nt[b]=n.getUint32(t),rt[b]=n.getUint32(t+=4);for(let b=16;b<80;b++){const S=nt[b-15]|0,H=rt[b-15]|0,N=ht(S,H,1)^ht(S,H,8)^ae(S,H,7),v=dt(S,H,1)^dt(S,H,8)^ce(S,H,7),A=nt[b-2]|0,m=rt[b-2]|0,q=ht(A,m,19)^It(A,m,61)^ae(A,m,6),L=dt(A,m,19)^Ot(A,m,61)^ce(A,m,6),U=sn(v,L,rt[b-7],rt[b-16]),P=an(U,N,q,nt[b-7],nt[b-16]);nt[b]=P|0,rt[b]=U|0}let{Ah:r,Al:i,Bh:f,Bl:o,Ch:a,Cl:s,Dh:u,Dl:p,Eh:h,El:l,Fh:B,Fl:I,Gh:E,Gl:c,Hh:g,Hl:x}=this;for(let b=0;b<80;b++){const S=ht(h,l,14)^ht(h,l,18)^It(h,l,41),H=dt(h,l,14)^dt(h,l,18)^Ot(h,l,41),N=h&B^~h&E,v=l&I^~l&c,A=cn(x,H,v,bn[b],rt[b]),m=ln(A,g,S,N,dn[b],nt[b]),q=A|0,L=ht(r,i,28)^It(r,i,34)^It(r,i,39),U=dt(r,i,28)^Ot(r,i,34)^Ot(r,i,39),P=r&f^r&a^f&a,d=i&o^i&s^o&s;g=E|0,x=c|0,E=B|0,c=I|0,B=h|0,I=l|0,{h,l}=Q(u|0,p|0,m|0,q|0),u=a|0,p=s|0,a=f|0,s=o|0,f=r|0,o=i|0;const w=on(q,U,d);r=fn(w,m,L,P),i=w|0}({h:r,l:i}=Q(this.Ah|0,this.Al|0,r|0,i|0)),{h:f,l:o}=Q(this.Bh|0,this.Bl|0,f|0,o|0),{h:a,l:s}=Q(this.Ch|0,this.Cl|0,a|0,s|0),{h:u,l:p}=Q(this.Dh|0,this.Dl|0,u|0,p|0),{h,l}=Q(this.Eh|0,this.El|0,h|0,l|0),{h:B,l:I}=Q(this.Fh|0,this.Fl|0,B|0,I|0),{h:E,l:c}=Q(this.Gh|0,this.Gl|0,E|0,c|0),{h:g,l:x}=Q(this.Hh|0,this.Hl|0,g|0,x|0),this.set(r,i,f,o,a,s,u,p,h,l,B,I,E,c,g,x)}roundClean(){gt(nt,rt)}destroy(){gt(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}class gn extends Ie{constructor(){super(48),this.Ah=z[0]|0,this.Al=z[1]|0,this.Bh=z[2]|0,this.Bl=z[3]|0,this.Ch=z[4]|0,this.Cl=z[5]|0,this.Dh=z[6]|0,this.Dl=z[7]|0,this.Eh=z[8]|0,this.El=z[9]|0,this.Fh=z[10]|0,this.Fl=z[11]|0,this.Gh=z[12]|0,this.Gl=z[13]|0,this.Hh=z[14]|0,this.Hl=z[15]|0}}const pn=$t(()=>new hn),wn=$t(()=>new Ie),yn=$t(()=>new gn);class Oe extends ge{constructor(n,t){super(),this.finished=!1,this.destroyed=!1,Pe(n);const r=Yt(t);if(this.iHash=n.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const i=this.blockLen,f=new Uint8Array(i);f.set(r.length>i?n.create().update(r).digest():r);for(let o=0;o<f.length;o++)f[o]^=54;this.iHash.update(f),this.oHash=n.create();for(let o=0;o<f.length;o++)f[o]^=106;this.oHash.update(f),gt(f)}update(n){return Nt(this),this.iHash.update(n),this}digestInto(n){Nt(this),Bt(n,this.outputLen),this.finished=!0,this.iHash.digestInto(n),this.oHash.update(n),this.oHash.digestInto(n),this.destroy()}digest(){const n=new Uint8Array(this.oHash.outputLen);return this.digestInto(n),n}_cloneInto(n){n||(n=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:r,finished:i,destroyed:f,blockLen:o,outputLen:a}=this;return n=n,n.finished=i,n.destroyed=f,n.blockLen=o,n.outputLen=a,n.oHash=t._cloneInto(n.oHash),n.iHash=r._cloneInto(n.iHash),n}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Ne=(e,n,t)=>new Oe(e,n).update(t).digest();Ne.create=(e,n)=>new Oe(e,n);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const le=BigInt(0),Mt=BigInt(1);function Tt(e,n){const t=n.negate();return e?t:n}function He(e,n){if(!Number.isSafeInteger(e)||e<=0||e>n)throw new Error("invalid window size, expected [1.."+n+"], got W="+e)}function Dt(e,n){He(e,n);const t=Math.ceil(n/e)+1,r=2**(e-1),i=2**e,f=Rt(e),o=BigInt(e);return{windows:t,windowSize:r,mask:f,maxNumber:i,shiftBy:o}}function ue(e,n,t){const{windowSize:r,mask:i,maxNumber:f,shiftBy:o}=t;let a=Number(e&i),s=e>>o;a>r&&(a-=f,s+=Mt);const u=n*r,p=u+Math.abs(a)-1,h=a===0,l=a<0,B=n%2!==0;return{nextN:s,offset:p,isZero:h,isNeg:l,isNegF:B,offsetF:u}}function mn(e,n){if(!Array.isArray(e))throw new Error("array expected");e.forEach((t,r)=>{if(!(t instanceof n))throw new Error("invalid point at index "+r)})}function En(e,n){if(!Array.isArray(e))throw new Error("array of scalars expected");e.forEach((t,r)=>{if(!n.isValid(t))throw new Error("invalid scalar at index "+r)})}const kt=new WeakMap,Ue=new WeakMap;function Zt(e){return Ue.get(e)||1}function xn(e,n){return{constTimeNegate:Tt,hasPrecomputes(t){return Zt(t)!==1},unsafeLadder(t,r,i=e.ZERO){let f=t;for(;r>le;)r&Mt&&(i=i.add(f)),f=f.double(),r>>=Mt;return i},precomputeWindow(t,r){const{windows:i,windowSize:f}=Dt(r,n),o=[];let a=t,s=a;for(let u=0;u<i;u++){s=a,o.push(s);for(let p=1;p<f;p++)s=s.add(a),o.push(s);a=s.double()}return o},wNAF(t,r,i){let f=e.ZERO,o=e.BASE;const a=Dt(t,n);for(let s=0;s<a.windows;s++){const{nextN:u,offset:p,isZero:h,isNeg:l,isNegF:B,offsetF:I}=ue(i,s,a);i=u,h?o=o.add(Tt(B,r[I])):f=f.add(Tt(l,r[p]))}return{p:f,f:o}},wNAFUnsafe(t,r,i,f=e.ZERO){const o=Dt(t,n);for(let a=0;a<o.windows&&i!==le;a++){const{nextN:s,offset:u,isZero:p,isNeg:h}=ue(i,a,o);if(i=s,!p){const l=r[u];f=f.add(h?l.negate():l)}}return f},getPrecomputes(t,r,i){let f=kt.get(r);return f||(f=this.precomputeWindow(r,t),t!==1&&kt.set(r,i(f))),f},wNAFCached(t,r,i){const f=Zt(t);return this.wNAF(f,this.getPrecomputes(f,t,i),r)},wNAFCachedUnsafe(t,r,i,f){const o=Zt(t);return o===1?this.unsafeLadder(t,r,f):this.wNAFUnsafe(o,this.getPrecomputes(o,t,i),r,f)},setWindowSize(t,r){He(r,n),Ue.set(t,r),kt.delete(t)}}}function Bn(e,n,t,r){if(mn(t,e),En(r,n),t.length!==r.length)throw new Error("arrays of points and scalars must have equal length");const i=e.ZERO,f=Ve(BigInt(t.length)),o=f>12?f-3:f>4?f-2:f?2:1,a=Rt(o),s=new Array(Number(a)+1).fill(i),u=Math.floor((n.BITS-1)/o)*o;let p=i;for(let h=u;h>=0;h-=o){s.fill(i);for(let B=0;B<r.length;B++){const I=r[B],E=Number(I>>BigInt(h)&a);s[E]=s[E].add(t[B])}let l=i;for(let B=s.length-1,I=i;B>0;B--)I=I.add(s[B]),l=l.add(I);if(p=p.add(l),h!==0)for(let B=0;B<o;B++)p=p.double()}return p}function Re(e){return $e(e.Fp),Lt(e,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...xe(e.n,e.nBitLength),...e,p:e.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function he(e){e.lowS!==void 0&&mt("lowS",e.lowS),e.prehash!==void 0&&mt("prehash",e.prehash)}function vn(e){const n=Re(e);Lt(n,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:t,Fp:r,a:i}=n;if(t){if(!r.eql(i,r.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...n})}class An extends Error{constructor(n=""){super(n)}}const _={Err:An,_tlv:{encode:(e,n)=>{const{Err:t}=_;if(e<0||e>256)throw new t("tlv.encode: wrong tag");if(n.length&1)throw new t("tlv.encode: unpadded data");const r=n.length/2,i=At(r);if(i.length/2&128)throw new t("tlv.encode: long form length too big");const f=r>127?At(i.length/2|128):"";return At(e)+f+i+n},decode(e,n){const{Err:t}=_;let r=0;if(e<0||e>256)throw new t("tlv.encode: wrong tag");if(n.length<2||n[r++]!==e)throw new t("tlv.decode: wrong tlv");const i=n[r++],f=!!(i&128);let o=0;if(!f)o=i;else{const s=i&127;if(!s)throw new t("tlv.decode(long): indefinite length not supported");if(s>4)throw new t("tlv.decode(long): byte length is too big");const u=n.subarray(r,r+s);if(u.length!==s)throw new t("tlv.decode: length bytes not complete");if(u[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(const p of u)o=o<<8|p;if(r+=s,o<128)throw new t("tlv.decode(long): not minimal encoding")}const a=n.subarray(r,r+o);if(a.length!==o)throw new t("tlv.decode: wrong value length");return{v:a,l:n.subarray(r+o)}}},_int:{encode(e){const{Err:n}=_;if(e<J)throw new n("integer: negative integers are not allowed");let t=At(e);if(Number.parseInt(t[0],16)&8&&(t="00"+t),t.length&1)throw new n("unexpected DER parsing assertion: unpadded hex");return t},decode(e){const{Err:n}=_;if(e[0]&128)throw new n("invalid signature integer: negative");if(e[0]===0&&!(e[1]&128))throw new n("invalid signature integer: unnecessary leading zero");return at(e)}},toSig(e){const{Err:n,_int:t,_tlv:r}=_,i=M("signature",e),{v:f,l:o}=r.decode(48,i);if(o.length)throw new n("invalid signature: left bytes after parsing");const{v:a,l:s}=r.decode(2,f),{v:u,l:p}=r.decode(2,s);if(p.length)throw new n("invalid signature: left bytes after parsing");return{r:t.decode(a),s:t.decode(u)}},hexFromSig(e){const{_tlv:n,_int:t}=_,r=n.encode(2,t.encode(e.r)),i=n.encode(2,t.encode(e.s)),f=r+i;return n.encode(48,f)}},J=BigInt(0),F=BigInt(1);BigInt(2);const de=BigInt(3);BigInt(4);function Sn(e){const n=vn(e),{Fp:t}=n,r=vt(n.n,n.nBitLength),i=n.toBytes||((E,c,g)=>{const x=c.toAffine();return Ut(Uint8Array.from([4]),t.toBytes(x.x),t.toBytes(x.y))}),f=n.fromBytes||(E=>{const c=E.subarray(1),g=t.fromBytes(c.subarray(0,t.BYTES)),x=t.fromBytes(c.subarray(t.BYTES,2*t.BYTES));return{x:g,y:x}});function o(E){const{a:c,b:g}=n,x=t.sqr(E),b=t.mul(x,E);return t.add(t.add(b,t.mul(E,c)),g)}if(!t.eql(t.sqr(n.Gy),o(n.Gx)))throw new Error("bad generator point: equation left != right");function a(E){return Jt(E,F,n.n)}function s(E){const{allowedPrivateKeyLengths:c,nByteLength:g,wrapPrivateKey:x,n:b}=n;if(c&&typeof E!="bigint"){if(pt(E)&&(E=Et(E)),typeof E!="string"||!c.includes(E.length))throw new Error("invalid private key");E=E.padStart(g*2,"0")}let S;try{S=typeof E=="bigint"?E:at(M("private key",E,g))}catch{throw new Error("invalid private key, expected hex or "+g+" bytes, got "+typeof E)}return x&&(S=K(S,b)),bt("private key",S,F,b),S}function u(E){if(!(E instanceof l))throw new Error("ProjectivePoint expected")}const p=re((E,c)=>{const{px:g,py:x,pz:b}=E;if(t.eql(b,t.ONE))return{x:g,y:x};const S=E.is0();c==null&&(c=S?t.ONE:t.inv(b));const H=t.mul(g,c),N=t.mul(x,c),v=t.mul(b,c);if(S)return{x:t.ZERO,y:t.ZERO};if(!t.eql(v,t.ONE))throw new Error("invZ was invalid");return{x:H,y:N}}),h=re(E=>{if(E.is0()){if(n.allowInfinityPoint&&!t.is0(E.py))return;throw new Error("bad point: ZERO")}const{x:c,y:g}=E.toAffine();if(!t.isValid(c)||!t.isValid(g))throw new Error("bad point: x or y not FE");const x=t.sqr(g),b=o(c);if(!t.eql(x,b))throw new Error("bad point: equation left != right");if(!E.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class l{constructor(c,g,x){if(c==null||!t.isValid(c))throw new Error("x required");if(g==null||!t.isValid(g)||t.is0(g))throw new Error("y required");if(x==null||!t.isValid(x))throw new Error("z required");this.px=c,this.py=g,this.pz=x,Object.freeze(this)}static fromAffine(c){const{x:g,y:x}=c||{};if(!c||!t.isValid(g)||!t.isValid(x))throw new Error("invalid affine point");if(c instanceof l)throw new Error("projective point not allowed");const b=S=>t.eql(S,t.ZERO);return b(g)&&b(x)?l.ZERO:new l(g,x,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(c){const g=Ee(t,c.map(x=>x.pz));return c.map((x,b)=>x.toAffine(g[b])).map(l.fromAffine)}static fromHex(c){const g=l.fromAffine(f(M("pointHex",c)));return g.assertValidity(),g}static fromPrivateKey(c){return l.BASE.multiply(s(c))}static msm(c,g){return Bn(l,r,c,g)}_setWindowSize(c){I.setWindowSize(this,c)}assertValidity(){h(this)}hasEvenY(){const{y:c}=this.toAffine();if(t.isOdd)return!t.isOdd(c);throw new Error("Field doesn't support isOdd")}equals(c){u(c);const{px:g,py:x,pz:b}=this,{px:S,py:H,pz:N}=c,v=t.eql(t.mul(g,N),t.mul(S,b)),A=t.eql(t.mul(x,N),t.mul(H,b));return v&&A}negate(){return new l(this.px,t.neg(this.py),this.pz)}double(){const{a:c,b:g}=n,x=t.mul(g,de),{px:b,py:S,pz:H}=this;let N=t.ZERO,v=t.ZERO,A=t.ZERO,m=t.mul(b,b),q=t.mul(S,S),L=t.mul(H,H),U=t.mul(b,S);return U=t.add(U,U),A=t.mul(b,H),A=t.add(A,A),N=t.mul(c,A),v=t.mul(x,L),v=t.add(N,v),N=t.sub(q,v),v=t.add(q,v),v=t.mul(N,v),N=t.mul(U,N),A=t.mul(x,A),L=t.mul(c,L),U=t.sub(m,L),U=t.mul(c,U),U=t.add(U,A),A=t.add(m,m),m=t.add(A,m),m=t.add(m,L),m=t.mul(m,U),v=t.add(v,m),L=t.mul(S,H),L=t.add(L,L),m=t.mul(L,U),N=t.sub(N,m),A=t.mul(L,q),A=t.add(A,A),A=t.add(A,A),new l(N,v,A)}add(c){u(c);const{px:g,py:x,pz:b}=this,{px:S,py:H,pz:N}=c;let v=t.ZERO,A=t.ZERO,m=t.ZERO;const q=n.a,L=t.mul(n.b,de);let U=t.mul(g,S),P=t.mul(x,H),d=t.mul(b,N),w=t.add(g,x),y=t.add(S,H);w=t.mul(w,y),y=t.add(U,P),w=t.sub(w,y),y=t.add(g,b);let O=t.add(S,N);return y=t.mul(y,O),O=t.add(U,d),y=t.sub(y,O),O=t.add(x,b),v=t.add(H,N),O=t.mul(O,v),v=t.add(P,d),O=t.sub(O,v),m=t.mul(q,y),v=t.mul(L,d),m=t.add(v,m),v=t.sub(P,m),m=t.add(P,m),A=t.mul(v,m),P=t.add(U,U),P=t.add(P,U),d=t.mul(q,d),y=t.mul(L,y),P=t.add(P,d),d=t.sub(U,d),d=t.mul(q,d),y=t.add(y,d),U=t.mul(P,y),A=t.add(A,U),U=t.mul(O,y),v=t.mul(w,v),v=t.sub(v,U),U=t.mul(w,P),m=t.mul(O,m),m=t.add(m,U),new l(v,A,m)}subtract(c){return this.add(c.negate())}is0(){return this.equals(l.ZERO)}wNAF(c){return I.wNAFCached(this,c,l.normalizeZ)}multiplyUnsafe(c){const{endo:g,n:x}=n;bt("scalar",c,J,x);const b=l.ZERO;if(c===J)return b;if(this.is0()||c===F)return this;if(!g||I.hasPrecomputes(this))return I.wNAFCachedUnsafe(this,c,l.normalizeZ);let{k1neg:S,k1:H,k2neg:N,k2:v}=g.splitScalar(c),A=b,m=b,q=this;for(;H>J||v>J;)H&F&&(A=A.add(q)),v&F&&(m=m.add(q)),q=q.double(),H>>=F,v>>=F;return S&&(A=A.negate()),N&&(m=m.negate()),m=new l(t.mul(m.px,g.beta),m.py,m.pz),A.add(m)}multiply(c){const{endo:g,n:x}=n;bt("scalar",c,F,x);let b,S;if(g){const{k1neg:H,k1:N,k2neg:v,k2:A}=g.splitScalar(c);let{p:m,f:q}=this.wNAF(N),{p:L,f:U}=this.wNAF(A);m=I.constTimeNegate(H,m),L=I.constTimeNegate(v,L),L=new l(t.mul(L.px,g.beta),L.py,L.pz),b=m.add(L),S=q.add(U)}else{const{p:H,f:N}=this.wNAF(c);b=H,S=N}return l.normalizeZ([b,S])[0]}multiplyAndAddUnsafe(c,g,x){const b=l.BASE,S=(N,v)=>v===J||v===F||!N.equals(b)?N.multiplyUnsafe(v):N.multiply(v),H=S(this,g).add(S(c,x));return H.is0()?void 0:H}toAffine(c){return p(this,c)}isTorsionFree(){const{h:c,isTorsionFree:g}=n;if(c===F)return!0;if(g)return g(l,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:c,clearCofactor:g}=n;return c===F?this:g?g(l,this):this.multiplyUnsafe(n.h)}toRawBytes(c=!0){return mt("isCompressed",c),this.assertValidity(),i(l,this,c)}toHex(c=!0){return mt("isCompressed",c),Et(this.toRawBytes(c))}}l.BASE=new l(n.Gx,n.Gy,t.ONE),l.ZERO=new l(t.ZERO,t.ONE,t.ZERO);const B=n.nBitLength,I=xn(l,n.endo?Math.ceil(B/2):B);return{CURVE:n,ProjectivePoint:l,normPrivateKeyToScalar:s,weierstrassEquation:o,isWithinCurveOrder:a}}function In(e){const n=Re(e);return Lt(n,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...n})}function On(e){const n=In(e),{Fp:t,n:r}=n,i=t.BYTES+1,f=2*t.BYTES+1;function o(d){return K(d,r)}function a(d){return jt(d,r)}const{ProjectivePoint:s,normPrivateKeyToScalar:u,weierstrassEquation:p,isWithinCurveOrder:h}=Sn({...n,toBytes(d,w,y){const O=w.toAffine(),R=t.toBytes(O.x),C=Ut;return mt("isCompressed",y),y?C(Uint8Array.from([w.hasEvenY()?2:3]),R):C(Uint8Array.from([4]),R,t.toBytes(O.y))},fromBytes(d){const w=d.length,y=d[0],O=d.subarray(1);if(w===i&&(y===2||y===3)){const R=at(O);if(!Jt(R,F,t.ORDER))throw new Error("Point is not on curve");const C=p(R);let Z;try{Z=t.sqrt(C)}catch(j){const W=j instanceof Error?": "+j.message:"";throw new Error("Point is not on curve"+W)}const k=(Z&F)===F;return(y&1)===1!==k&&(Z=t.neg(Z)),{x:R,y:Z}}else if(w===f&&y===4){const R=t.fromBytes(O.subarray(0,t.BYTES)),C=t.fromBytes(O.subarray(t.BYTES,2*t.BYTES));return{x:R,y:C}}else{const R=i,C=f;throw new Error("invalid Point, expected length of "+R+", or uncompressed "+C+", got "+w)}}}),l=d=>Et(xt(d,n.nByteLength));function B(d){const w=r>>F;return d>w}function I(d){return B(d)?o(-d):d}const E=(d,w,y)=>at(d.slice(w,y));class c{constructor(w,y,O){bt("r",w,F,r),bt("s",y,F,r),this.r=w,this.s=y,O!=null&&(this.recovery=O),Object.freeze(this)}static fromCompact(w){const y=n.nByteLength;return w=M("compactSignature",w,y*2),new c(E(w,0,y),E(w,y,2*y))}static fromDER(w){const{r:y,s:O}=_.toSig(M("DER",w));return new c(y,O)}assertValidity(){}addRecoveryBit(w){return new c(this.r,this.s,w)}recoverPublicKey(w){const{r:y,s:O,recovery:R}=this,C=N(M("msgHash",w));if(R==null||![0,1,2,3].includes(R))throw new Error("recovery id invalid");const Z=R===2||R===3?y+n.n:y;if(Z>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");const k=(R&1)===0?"02":"03",j=s.fromHex(k+l(Z)),W=a(Z),G=o(-C*W),ct=o(O*W),X=s.BASE.multiplyAndAddUnsafe(j,G,ct);if(!X)throw new Error("point at infinify");return X.assertValidity(),X}hasHighS(){return B(this.s)}normalizeS(){return this.hasHighS()?new c(this.r,o(-this.s),this.recovery):this}toDERRawBytes(){return Ht(this.toDERHex())}toDERHex(){return _.hexFromSig(this)}toCompactRawBytes(){return Ht(this.toCompactHex())}toCompactHex(){return l(this.r)+l(this.s)}}const g={isValidPrivateKey(d){try{return u(d),!0}catch{return!1}},normPrivateKeyToScalar:u,randomPrivateKey:()=>{const d=ve(n.n);return Je(n.randomBytes(d),n.n)},precompute(d=8,w=s.BASE){return w._setWindowSize(d),w.multiply(BigInt(3)),w}};function x(d,w=!0){return s.fromPrivateKey(d).toRawBytes(w)}function b(d){const w=pt(d),y=typeof d=="string",O=(w||y)&&d.length;return w?O===i||O===f:y?O===2*i||O===2*f:d instanceof s}function S(d,w,y=!0){if(b(d))throw new Error("first arg must be private key");if(!b(w))throw new Error("second arg must be public key");return s.fromHex(w).multiply(u(d)).toRawBytes(y)}const H=n.bits2int||function(d){if(d.length>8192)throw new Error("input is too large");const w=at(d),y=d.length*8-n.nBitLength;return y>0?w>>BigInt(y):w},N=n.bits2int_modN||function(d){return o(H(d))},v=Rt(n.nBitLength);function A(d){return bt("num < 2^"+n.nBitLength,d,J,v),xt(d,n.nByteLength)}function m(d,w,y=q){if(["recovered","canonical"].some(it=>it in y))throw new Error("sign() legacy options not supported");const{hash:O,randomBytes:R}=n;let{lowS:C,prehash:Z,extraEntropy:k}=y;C==null&&(C=!0),d=M("msgHash",d),he(y),Z&&(d=M("prehashed msgHash",O(d)));const j=N(d),W=u(w),G=[A(W),A(j)];if(k!=null&&k!==!1){const it=k===!0?R(t.BYTES):k;G.push(M("extraEntropy",it))}const ct=Ut(...G),X=j;function qt(it){const lt=H(it);if(!h(lt))return;const Ct=a(lt),wt=s.BASE.multiply(lt).toAffine(),ot=o(wt.x);if(ot===J)return;const ft=o(Ct*o(X+ot*W));if(ft===J)return;let yt=(wt.x===ot?0:2)|Number(wt.y&F),te=ft;return C&&B(ft)&&(te=I(ft),yt^=1),new c(ot,te,yt)}return{seed:ct,k2sig:qt}}const q={lowS:n.lowS,prehash:!1},L={lowS:n.lowS,prehash:!1};function U(d,w,y=q){const{seed:O,k2sig:R}=m(d,w,y),C=n;return Ge(C.hash.outputLen,C.nByteLength,C.hmac)(O,R)}s.BASE._setWindowSize(8);function P(d,w,y,O=L){var ft;const R=d;w=M("msgHash",w),y=M("publicKey",y);const{lowS:C,prehash:Z,format:k}=O;if(he(O),"strict"in O)throw new Error("options.strict was renamed to lowS");if(k!==void 0&&k!=="compact"&&k!=="der")throw new Error("format must be compact or der");const j=typeof R=="string"||pt(R),W=!j&&!k&&typeof R=="object"&&R!==null&&typeof R.r=="bigint"&&typeof R.s=="bigint";if(!j&&!W)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let G,ct;try{if(W&&(G=new c(R.r,R.s)),j){try{k!=="compact"&&(G=c.fromDER(R))}catch(yt){if(!(yt instanceof _.Err))throw yt}!G&&k!=="der"&&(G=c.fromCompact(R))}ct=s.fromHex(y)}catch{return!1}if(!G||C&&G.hasHighS())return!1;Z&&(w=n.hash(w));const{r:X,s:qt}=G,it=N(w),lt=a(qt),Ct=o(it*lt),wt=o(X*lt),ot=(ft=s.BASE.multiplyAndAddUnsafe(ct,Ct,wt))==null?void 0:ft.toAffine();return ot?o(ot.x)===X:!1}return{CURVE:n,getPublicKey:x,getSharedSecret:S,sign:U,verify:P,ProjectivePoint:s,Signature:c,utils:g}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Nn(e){return{hash:e,hmac:(n,...t)=>Ne(e,n,De(...t)),randomBytes:ke}}function Xt(e,n){const t=r=>On({...e,...Nn(r)});return{...t(n),create:t}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Le=vt(BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff")),Hn=Le.create(BigInt("-3")),Un=BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"),Rn=Xt({a:Hn,b:Un,Fp:Le,n:BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),Gx:BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),Gy:BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"),h:BigInt(1),lowS:!1},pn),qe=vt(BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff")),Ln=qe.create(BigInt("-3")),qn=BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef");Xt({a:Ln,b:qn,Fp:qe,n:BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"),Gx:BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"),Gy:BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f"),h:BigInt(1),lowS:!1},yn);const Ce=vt(BigInt("0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff")),Cn=Ce.create(BigInt("-3")),Fn=BigInt("0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00");Xt({a:Cn,b:Fn,Fp:Ce,n:BigInt("0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409"),Gx:BigInt("0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66"),Gy:BigInt("0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650"),h:BigInt(1),lowS:!1,allowedPrivateKeyLengths:[130,131,132]},wn);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const be=Rn;async function Dn(e,n){const t=new TextEncoder,r=e?typeof e=="string"?t.encode(zn(e)):e:crypto.getRandomValues(new Uint8Array(32)),i=[],f=t.encode(i.join("|")),o=new Uint8Array(r.length+f.length);if(o.set(r),o.set(f,r.length),o.length<16)throw new Error(`Insufficient input entropy (${o.length})`);const a="v1",s=[{label:"signing",type:"pub/priv"},{label:"encryption",type:"epub/epriv"}],[u,p]=await Promise.all(s.map(async({label:h})=>{const l=t.encode(`${h}-${a}`),B=await Tn(o,l);if(!be.utils.isValidPrivateKey(B))throw new Error(`Invalid private key for ${h}`);const I=be.getPublicKey(B,!1);return{pub:Pn(I),priv:Wt(B)}}));return{pub:u.pub,priv:u.priv,epub:p.pub,epriv:p.priv}}function Wt(e){return btoa(String.fromCharCode(...e)).replace(/\//g,"_").replace(/=/g,"").replace(/\+/g,"-")}function Pn(e){if(e[0]!==4)throw new Error("Invalid uncompressed public key format");return[Wt(e.slice(1,33)),Wt(e.slice(33,65))].join(".")}function zn(e){return e.normalize("NFC").trim()}async function Tn(e,n,t=3e5){const r=await crypto.subtle.importKey("raw",e,{name:"PBKDF2"},!1,["deriveBits"]),i=await crypto.subtle.deriveBits({name:"PBKDF2",salt:n,iterations:t,hash:"SHA-256"},r,256);return new Uint8Array(i)}export{Dn as Z};
