var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// src/index.ts
__export(exports, {
  PageContext: () => PageContext,
  default: () => src_default
});

// src/constants.ts
var MODULE_ID_VIRTUAL = "/@vite-plugin-pages/generated-pages";
var MODULE_IDS = [
  "~pages",
  "~react-pages",
  "pages-generated",
  "virtual:generated-pages",
  "virtual:generated-pages-react"
];

// src/context.ts
var import_path6 = __toModule(require("path"));
var import_deep_equal = __toModule(require("deep-equal"));
var import_utils8 = __toModule(require("@antfu/utils"));

// src/options.ts
var import_path3 = __toModule(require("path"));
var import_utils4 = __toModule(require("@antfu/utils"));

// src/files.ts
var import_path2 = __toModule(require("path"));
var import_utils2 = __toModule(require("@antfu/utils"));
var import_fast_glob = __toModule(require("fast-glob"));

// src/utils.ts
var import_path = __toModule(require("path"));
var import_debug = __toModule(require("debug"));
var import_utils = __toModule(require("@antfu/utils"));
var debug = {
  hmr: (0, import_debug.default)("vite-plugin-pages:hmr"),
  routeBlock: (0, import_debug.default)("vite-plugin-pages:routeBlock"),
  options: (0, import_debug.default)("vite-plugin-pages:options"),
  pages: (0, import_debug.default)("vite-plugin-pages:pages"),
  search: (0, import_debug.default)("vite-plugin-pages:search"),
  env: (0, import_debug.default)("vite-plugin-pages:env"),
  cache: (0, import_debug.default)("vite-plugin-pages:cache"),
  resolver: (0, import_debug.default)("vite-plugin-pages:resolver")
};
function extsToGlob(extensions) {
  return extensions.length > 1 ? `{${extensions.join(",")}}` : extensions[0] || "";
}
function countSlash(value) {
  return (value.match(/\//g) || []).length;
}
function isPagesDir(path, options) {
  for (const page of options.dirs) {
    const dirPath = (0, import_utils.slash)((0, import_path.resolve)(options.root, page.dir));
    if (path.startsWith(dirPath))
      return true;
  }
  return false;
}
function isTarget(path, options) {
  return isPagesDir(path, options) && options.extensionsRE.test(path);
}
var dynamicRouteRE = /^\[.+\]$/;
var nuxtDynamicRouteRE = /^_[\s\S]*$/;
function isDynamicRoute(routePath, nuxtStyle = false) {
  return nuxtStyle ? nuxtDynamicRouteRE.test(routePath) : dynamicRouteRE.test(routePath);
}
function isCatchAllRoute(routePath, nuxtStyle = false) {
  return nuxtStyle ? /^_$/.test(routePath) : /^\[\.{3}/.test(routePath);
}
function resolveImportMode(filepath, options) {
  const mode = options.importMode;
  if (typeof mode === "function")
    return mode(filepath);
  for (const page of options.dirs) {
    if (options.syncIndex && page.baseRoute === "" && filepath === `/${page.dir}/index.vue`)
      return "sync";
  }
  return mode;
}
function pathToName(filepath) {
  return filepath.replace(/[_.\-\\/]/g, "_").replace(/[[:\]()]/g, "$");
}
function invalidatePagesModule(server) {
  const { moduleGraph } = server;
  const module2 = moduleGraph.getModuleById(MODULE_ID_VIRTUAL);
  if (module2) {
    moduleGraph.invalidateModule(module2);
    return module2;
  }
}

// src/files.ts
function getIgnore(exclude) {
  return ["node_modules", ".git", "**/__*__/**", ...exclude];
}
function getPageDirs(PageOptions, root, exclude) {
  const dirs = (0, import_fast_glob.sync)((0, import_utils2.slash)(PageOptions.dir), {
    ignore: getIgnore(exclude),
    onlyDirectories: true,
    dot: true,
    unique: true,
    cwd: root
  });
  const pageDirs = dirs.map((dir) => __spreadProps(__spreadValues({}, PageOptions), {
    dir
  }));
  return pageDirs;
}
function getPageFiles(path, options) {
  const {
    exclude,
    extensions
  } = options;
  const ext = extsToGlob(extensions);
  const files = (0, import_fast_glob.sync)((0, import_utils2.slash)((0, import_path2.join)(path, `**/*.${ext}`)), {
    ignore: getIgnore(exclude),
    onlyFiles: true
  });
  return files;
}

// src/options.ts
function resolvePageDirs(dirs, root, exclude) {
  dirs = (0, import_utils4.toArray)(dirs);
  return dirs.flatMap((dirPath) => {
    const option = typeof dirPath === "string" ? { dir: dirPath, baseRoute: "" } : dirPath;
    option.dir = (0, import_utils4.slash)((0, import_path3.resolve)(root, option.dir)).replace(`${root}/`, "");
    option.baseRoute = option.baseRoute.replace(/^\//, "").replace(/\/$/, "");
    return getPageDirs(option, root, exclude);
  });
}
function resolveOptions(userOptions, viteRoot) {
  const {
    dirs = ["src/pages"],
    routeBlockLang = "json5",
    exclude = [],
    syncIndex = true,
    nuxtStyle = false,
    resolver = "vue",
    extendRoute,
    onRoutesGenerated,
    onClientGenerated
  } = userOptions;
  const root = viteRoot || (0, import_utils4.slash)(process.cwd());
  const importMode = userOptions.importMode || (resolver === "react" ? "sync" : "async");
  const extensions = userOptions.extensions || (resolver === "react" ? ["tsx", "jsx"] : ["vue", "ts", "js"]);
  const extensionsRE = new RegExp(`\\.(${extensions.join("|")})$`);
  const resolvedDirs = resolvePageDirs(dirs, root, exclude);
  const resolvedOptions = {
    dirs: resolvedDirs,
    routeBlockLang,
    root,
    extensions,
    importMode,
    exclude,
    syncIndex,
    nuxtStyle,
    resolver,
    extensionsRE,
    extendRoute,
    onRoutesGenerated,
    onClientGenerated
  };
  return resolvedOptions;
}

// src/resolvers/react.ts
var import_path4 = __toModule(require("path"));

// src/stringify.ts
var componentRE = /"(?:component|element)":("(.*?)")/g;
var hasFunctionRE = /"(?:props|beforeEnter)":("(.*?)")/g;
var multilineCommentsRE = /\/\*(.|[\r\n])*?\*\//gm;
var singlelineCommentsRE = /\/\/.*/g;
function replaceFunction(_, value) {
  if (value instanceof Function || typeof value === "function") {
    const fnBody = value.toString().replace(multilineCommentsRE, "").replace(singlelineCommentsRE, "").replace(/(\t|\n|\r|\s)/g, "");
    if (fnBody.length < 8 || fnBody.substring(0, 8) !== "function")
      return `_NuFrRa_${fnBody}`;
    return fnBody;
  }
  return value;
}
function stringifyRoutes(preparedRoutes, options) {
  const imports = [];
  function componentReplacer(str, replaceStr, path) {
    const mode = resolveImportMode(path, options);
    if (mode === "sync") {
      const importName = pathToName(path);
      const importStr = `import ${importName} from "${path}"`;
      if (!imports.includes(importStr))
        imports.push(importStr);
      if (options.resolver === "react")
        return str.replace(replaceStr, `React.createElement(${importName})`);
      else
        return str.replace(replaceStr, importName);
    } else {
      if (options.resolver === "react")
        return str.replace(replaceStr, `React.lazy(() => import('${path}'))`);
      else
        return str.replace(replaceStr, `() => import('${path}')`);
    }
  }
  function functionReplacer(str, replaceStr, content) {
    if (content.startsWith("function"))
      return str.replace(replaceStr, content);
    if (content.startsWith("_NuFrRa_"))
      return str.replace(replaceStr, content.slice(8));
    return str;
  }
  const stringRoutes = JSON.stringify(preparedRoutes, replaceFunction).replace(componentRE, componentReplacer).replace(hasFunctionRE, functionReplacer);
  return {
    imports,
    stringRoutes
  };
}
function generateClientCode(routes, options) {
  const { imports, stringRoutes } = stringifyRoutes(routes, options);
  if (options.resolver === "react")
    imports.push('import React from "react"');
  return `${imports.join(";\n")};

const routes = ${stringRoutes};

export default routes;`;
}

// src/resolvers/react.ts
function prepareRoutes(routes, options, parent) {
  var _a;
  for (const route of routes) {
    if (parent)
      route.path = route.path.replace(/^\//, "");
    if (route.children)
      route.children = prepareRoutes(route.children, options, route);
    delete route.rawRoute;
    if (route.index)
      delete route.path;
    Object.assign(route, ((_a = options.extendRoute) == null ? void 0 : _a.call(options, route, parent)) || {});
  }
  return routes;
}
async function resolveReactRoutes(ctx) {
  var _a, _b, _c, _d;
  const { nuxtStyle } = ctx.options;
  const pageRoutes = [...ctx.pageRouteMap.values()].sort((a, b) => {
    if (countSlash(a.route) === countSlash(b.route)) {
      const aDynamic = a.route.split("/").some((r) => isDynamicRoute(r, nuxtStyle));
      const bDynamic = b.route.split("/").some((r) => isDynamicRoute(r, nuxtStyle));
      if (aDynamic === bDynamic)
        return a.route.localeCompare(b.route);
      else
        return aDynamic ? 1 : -1;
    } else {
      return countSlash(a.route) - countSlash(b.route);
    }
  });
  const routes = [];
  pageRoutes.forEach((page) => {
    const pathNodes = page.route.split("/");
    const element = page.path.replace(ctx.root, "");
    let parentRoutes = routes;
    for (let i = 0; i < pathNodes.length; i++) {
      const node = pathNodes[i];
      const isDynamic = isDynamicRoute(node, nuxtStyle);
      const isCatchAll = isCatchAllRoute(node, nuxtStyle);
      const normalizedName = isDynamic ? nuxtStyle ? isCatchAll ? "all" : node.replace(/^_/, "") : node.replace(/^\[(\.{3})?/, "").replace(/\]$/, "") : node;
      const normalizedPath = normalizedName.toLowerCase();
      const route = {
        path: "",
        rawRoute: pathNodes.slice(0, i + 1).join("/")
      };
      if (i === pathNodes.length - 1)
        route.element = element;
      if (!route.path && normalizedPath === "index") {
        route.index = true;
      } else if (normalizedPath !== "index") {
        if (isDynamic) {
          route.path = `:${normalizedName}`;
          if (isCatchAll)
            route.path = "*";
        } else {
          route.path = `${normalizedPath}`;
        }
      }
      const parent = parentRoutes.find((parent2) => {
        return pathNodes.slice(0, i).join("/") === parent2.rawRoute;
      });
      if (parent) {
        parent.children = parent.children || [];
        parentRoutes = parent.children;
      }
      const exits = parentRoutes.some((parent2) => {
        return pathNodes.slice(0, i + 1).join("/") === parent2.rawRoute;
      });
      if (!exits)
        parentRoutes.push(route);
    }
  });
  let finalRoutes = prepareRoutes(routes, ctx.options);
  const allRoute = finalRoutes.find((i) => {
    return isCatchAllRoute((0, import_path4.parse)(i.element).name, nuxtStyle);
  });
  if (allRoute) {
    finalRoutes = finalRoutes.filter((i) => !i.element || !isCatchAllRoute((0, import_path4.parse)(i.element).name, nuxtStyle));
    finalRoutes.push(allRoute);
  }
  finalRoutes = await ((_b = (_a = ctx.options).onRoutesGenerated) == null ? void 0 : _b.call(_a, finalRoutes)) || finalRoutes;
  let client = generateClientCode(finalRoutes, ctx.options);
  client = await ((_d = (_c = ctx.options).onClientGenerated) == null ? void 0 : _d.call(_c, client)) || client;
  return client;
}

// src/resolvers/vue.ts
var import_path5 = __toModule(require("path"));
function prepareRoutes2(ctx, routes, parent) {
  var _a, _b;
  for (const route of routes) {
    if (route.name)
      route.name = route.name.replace(/-index$/, "");
    if (parent)
      route.path = route.path.replace(/^\//, "");
    if (route.children) {
      delete route.name;
      route.children = prepareRoutes2(ctx, route.children, route);
    }
    route.props = true;
    delete route.rawRoute;
    if (route.customBlock) {
      Object.assign(route, route.customBlock || {});
      delete route.customBlock;
    }
    Object.assign(route, ((_b = (_a = ctx.options).extendRoute) == null ? void 0 : _b.call(_a, route, parent)) || {});
  }
  return routes;
}
async function resolveVueRoutes(ctx) {
  var _a, _b, _c, _d;
  const { nuxtStyle } = ctx.options;
  const pageRoutes = [...ctx.pageRouteMap.values()].sort((a, b) => {
    if (countSlash(a.route) === countSlash(b.route)) {
      const aDynamic = a.route.split("/").some((r) => isDynamicRoute(r, nuxtStyle));
      const bDynamic = b.route.split("/").some((r) => isDynamicRoute(r, nuxtStyle));
      if (aDynamic === bDynamic)
        return a.route.localeCompare(b.route);
      else
        return aDynamic ? 1 : -1;
    } else {
      return countSlash(a.route) - countSlash(b.route);
    }
  });
  const routes = [];
  pageRoutes.forEach((page) => {
    const pathNodes = page.route.split("/");
    const component = page.path.replace(ctx.root, "");
    const customBlock = ctx.customBlockMap.get(page.path);
    const route = {
      name: "",
      path: "",
      component,
      customBlock,
      rawRoute: page.route
    };
    let parentRoutes = routes;
    for (let i = 0; i < pathNodes.length; i++) {
      const node = pathNodes[i];
      const isDynamic = isDynamicRoute(node, nuxtStyle);
      const isCatchAll = isCatchAllRoute(node, nuxtStyle);
      const normalizedName = isDynamic ? nuxtStyle ? isCatchAll ? "all" : node.replace(/^_/, "") : node.replace(/^\[(\.{3})?/, "").replace(/\]$/, "") : node;
      const normalizedPath = normalizedName.toLowerCase();
      route.name += route.name ? `-${normalizedName}` : normalizedName;
      const parent = parentRoutes.find((parent2) => {
        return route.rawRoute.startsWith(parent2.rawRoute);
      });
      if (parent) {
        parent.children = parent.children || [];
        parentRoutes = parent.children;
        route.path = "";
      } else if (normalizedName.toLowerCase() === "index") {
        if (!route.path)
          route.path = "/";
      } else if (normalizedName.toLowerCase() !== "index") {
        if (isDynamic) {
          route.path += `/:${normalizedName}`;
          if (isCatchAll)
            route.path += "(.*)*";
        } else {
          route.path += `/${normalizedPath}`;
        }
      }
    }
    parentRoutes.push(route);
  });
  let finalRoutes = prepareRoutes2(ctx, routes);
  const allRoute = finalRoutes.find((i) => {
    return isCatchAllRoute((0, import_path5.parse)(i.component).name, nuxtStyle);
  });
  if (allRoute) {
    finalRoutes = finalRoutes.filter((i) => !isCatchAllRoute((0, import_path5.parse)(i.component).name, nuxtStyle));
    finalRoutes.push(allRoute);
  }
  finalRoutes = await ((_b = (_a = ctx.options).onRoutesGenerated) == null ? void 0 : _b.call(_a, finalRoutes)) || finalRoutes;
  let client = generateClientCode(finalRoutes, ctx.options);
  client = await ((_d = (_c = ctx.options).onClientGenerated) == null ? void 0 : _d.call(_c, client)) || client;
  return client;
}

// src/customBlock.ts
var import_fs = __toModule(require("fs"));
var import_json5 = __toModule(require("json5"));
var import_yaml = __toModule(require("yaml"));
var import_local_pkg = __toModule(require("local-pkg"));
async function parseSFC(code) {
  try {
    const { parse: parse3 } = await (0, import_local_pkg.importModule)("@vue/compiler-sfc");
    return parse3(code, {
      pad: "space"
    }).descriptor;
  } catch {
    throw new Error(`[vite-plugin-pages] Vue3's "@vue/compiler-sfc" is required.`);
  }
}
function parseCustomBlock(block, filePath, options) {
  var _a;
  const lang = (_a = block.lang) != null ? _a : options.routeBlockLang;
  if (lang === "json5") {
    try {
      return import_json5.default.parse(block.content);
    } catch (err) {
      throw new Error(`Invalid JSON5 format of <${block.type}> content in ${filePath}
${err.message}`);
    }
  } else if (lang === "json") {
    try {
      return JSON.parse(block.content);
    } catch (err) {
      throw new Error(`Invalid JSON format of <${block.type}> content in ${filePath}
${err.message}`);
    }
  } else if (lang === "yaml" || lang === "yml") {
    try {
      return import_yaml.default.parse(block.content);
    } catch (err) {
      throw new Error(`Invalid YAML format of <${block.type}> content in ${filePath}
${err.message}`);
    }
  }
}
async function getRouteBlock(path, options) {
  const content = import_fs.default.readFileSync(path, "utf8");
  const parsed = await parseSFC(content);
  const blockStr = parsed.customBlocks.find((b) => b.type === "route");
  if (!blockStr)
    return;
  const result = parseCustomBlock(blockStr, path, options);
  return result;
}

// src/context.ts
var PageContext = class {
  constructor(userOptions = {}) {
    this._pageRouteMap = new Map();
    this._customBlockMap = new Map();
    this.root = (0, import_utils8.slash)(process.cwd());
    this.rawOptions = userOptions;
    this.options = resolveOptions(userOptions, this.root);
    debug.options(this.options);
    this.setResolver(this.options.resolver);
  }
  setRoot(root) {
    if (this.root === root)
      return;
    debug.env("root", root);
    this.root = (0, import_utils8.slash)(root);
    this.options = resolveOptions(this.rawOptions, this.root);
  }
  setResolver(resolver) {
    debug.resolver(resolver);
    this.options.resolver = resolver;
  }
  setupViteServer(server) {
    if (this._server === server)
      return;
    this._server = server;
    this.setupWatcher(server.watcher);
  }
  setupWatcher(watcher) {
    watcher.on("unlink", (path) => {
      path = (0, import_utils8.slash)(path);
      if (!isTarget(path, this.options))
        return;
      this.removePage(path);
      this.onUpdate();
    });
    watcher.on("add", async (path) => {
      path = (0, import_utils8.slash)(path);
      if (!isTarget(path, this.options))
        return;
      const page = this.options.dirs.find((i) => path.startsWith(`/${i.dir}`));
      await this.addPage(path, page);
      this.onUpdate();
    });
    watcher.on("change", async (path) => {
      path = (0, import_utils8.slash)(path);
      if (!isTarget(path, this.options))
        return;
      const page = this._pageRouteMap.get(path);
      if (page)
        this.checkCustomBlockChange(path);
    });
  }
  async addPage(path, pageDir) {
    debug.pages("add", path);
    for (const p of (0, import_utils8.toArray)(path)) {
      const pageDirPath = (0, import_utils8.slash)((0, import_path6.resolve)(this.root, pageDir.dir));
      const route = (0, import_utils8.slash)((0, import_path6.join)(pageDir.baseRoute, p.replace(`${pageDirPath}/`, "").replace((0, import_path6.extname)(p), "")));
      this._pageRouteMap.set(p, {
        path: p,
        route
      });
      await this.checkCustomBlockChange(p);
    }
  }
  removePage(path) {
    debug.pages("remove", path);
    (0, import_utils8.toArray)(path).forEach((p) => {
      this._pageRouteMap.delete(p);
      this._customBlockMap.delete(p);
    });
  }
  async checkCustomBlockChange(path) {
    if (this.options.resolver !== "vue")
      return;
    const exitsCustomBlock = this._customBlockMap.get(path);
    const customBlock = await getRouteBlock(path, this.options);
    if (!exitsCustomBlock && !customBlock)
      return;
    if (!customBlock) {
      this._customBlockMap.delete(path);
      debug.routeBlock("%s deleted", path);
      return;
    }
    if (!exitsCustomBlock || !(0, import_deep_equal.default)(exitsCustomBlock, customBlock)) {
      debug.routeBlock("%s old: %O", path, exitsCustomBlock);
      debug.routeBlock("%s new: %O", path, customBlock);
      this._customBlockMap.set(path, customBlock);
      this.onUpdate();
    }
  }
  onUpdate() {
    if (!this._server)
      return;
    invalidatePagesModule(this._server);
    debug.hmr("Reload generated pages.");
    this._server.ws.send({
      type: "full-reload"
    });
  }
  async resolveRoutes() {
    if (this.options.resolver === "vue")
      return await resolveVueRoutes(this);
    if (this.options.resolver === "react")
      return await resolveReactRoutes(this);
  }
  async searchGlob() {
    const pageDirFiles = this.options.dirs.map((page) => {
      const pagesDirPath = (0, import_utils8.slash)((0, import_path6.resolve)(this.options.root, page.dir));
      const files = getPageFiles(pagesDirPath, this.options);
      debug.search(page.dir, files);
      return __spreadProps(__spreadValues({}, page), {
        files: files.map((file) => (0, import_utils8.slash)(file))
      });
    });
    for (const page of pageDirFiles)
      await this.addPage(page.files, page);
    debug.cache(this.pageRouteMap);
    debug.cache(this.customBlockMap);
  }
  get debug() {
    return debug;
  }
  get pageRouteMap() {
    return this._pageRouteMap;
  }
  get customBlockMap() {
    return this._customBlockMap;
  }
};

// src/index.ts
function pagesPlugin(userOptions = {}) {
  const ctx = new PageContext(userOptions);
  return {
    name: "vite-plugin-pages",
    enforce: "pre",
    async configResolved(config) {
      ctx.setRoot(config.root);
      await ctx.searchGlob();
      if (config.plugins.find((i) => i.name === "vite:react-refresh"))
        ctx.setResolver("react");
    },
    configureServer(server) {
      ctx.setupViteServer(server);
    },
    resolveId(id) {
      return MODULE_IDS.includes(id) ? MODULE_ID_VIRTUAL : null;
    },
    async load(id) {
      if (id !== MODULE_ID_VIRTUAL)
        return;
      return ctx.resolveRoutes();
    },
    async transform(_code, id) {
      if (!/vue&type=route/.test(id))
        return;
      return {
        code: "export default {};",
        map: null
      };
    }
  };
}
var src_default = pagesPlugin;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  PageContext
});
