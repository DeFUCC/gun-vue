declare class UnoGenerator {
    userConfig: UserConfig;
    defaults: UserConfigDefaults;
    version: string;
    private _cache;
    config: ResolvedConfig;
    blocked: Set<string>;
    parentOrders: Map<string, number>;
    constructor(userConfig?: UserConfig, defaults?: UserConfigDefaults);
    setConfig(userConfig?: UserConfig, defaults?: UserConfigDefaults): void;
    applyExtractors(code: string, id?: string, set?: Set<string>): Promise<Set<string>>;
    generate(input: string | Set<string>, { id, scope, preflights, safelist, minify, }?: GenerateOptions): Promise<GenerateResult>;
    matchVariants(raw: string, current?: string): VariantMatchedResult;
    applyVariants(parsed: ParsedUtil, variantHandlers?: VariantHandler[], raw?: string): readonly [string, CSSEntries, string | undefined];
    constructCustomCSS(context: Readonly<RuleContext>, body: CSSObject | CSSEntries, overrideSelector?: string): string;
    parseUtil(input: string | VariantMatchedResult, context: RuleContext, internal?: boolean): Promise<ParsedUtil | RawUtil | undefined>;
    stringifyUtil(parsed?: ParsedUtil | RawUtil): StringifiedUtil | undefined;
    expandShortcut(processed: string, context: RuleContext, depth?: number): [string[], RuleMeta | undefined] | undefined;
    stringifyShortcuts(parent: VariantMatchedResult, context: RuleContext, expanded: string[], meta?: RuleMeta): Promise<StringifiedUtil[] | undefined>;
    isBlocked(raw: string): boolean;
}
declare function createGenerator(config?: UserConfig, defaults?: UserConfigDefaults): UnoGenerator;
declare const hasScopePlaceholder: (css: string) => RegExpMatchArray | null;

declare type Awaitable<T> = T | Promise<T>;
declare type ArgumentType<T> = T extends ((...args: infer A) => any) ? A : never;
declare type Shift<T> = T extends [_: any, ...args: infer A] ? A : never;
declare type RestArgs<T> = Shift<ArgumentType<T>>;
declare type DeepPartial<T> = {
    [P in keyof T]?: DeepPartial<T[P]>;
};
declare type FlatObjectTuple<T> = {
    [K in keyof T]: T[K];
};
declare type PartialByKeys<T, K extends keyof T = keyof T> = FlatObjectTuple<Partial<Pick<T, Extract<keyof T, K>>> & Omit<T, K>>;
declare type CSSObject = Record<string, string | number | undefined>;
declare type CSSEntries = [string, string | number | undefined][];
interface RuleContext<Theme extends {} = {}> {
    /**
     * Unprocessed selector from user input.
     * Useful for generating CSS rule.
     */
    rawSelector: string;
    /**
     * Current selector for rule matching
     */
    currentSelector: string;
    /**
     * UnoCSS generator instance
     */
    generator: UnoGenerator;
    /**
     * The theme object
     */
    theme: Theme;
    /**
     * Matched variants handlers for this rule.
     */
    variantHandlers: VariantHandler[];
    /**
     * Constrcut a custom CSS rule.
     * Variants and selector escaping will be handled automatically.
     */
    constructCSS: (body: CSSEntries | CSSObject, overrideSelector?: string) => string;
}
interface ExtractorContext {
    readonly original: string;
    code: string;
    id?: string;
}
interface Extractor {
    name: string;
    extract(ctx: ExtractorContext): Awaitable<Set<string> | undefined>;
    order?: number;
}
interface RuleMeta {
    /**
     * The layer name of this rule.
     * @default 'default'
     */
    layer?: string;
    /**
     * Internal rules will only be matched for shortcuts but not the user code.
     * @default false
     */
    internal?: boolean;
}
declare type DynamicMatcher<Theme extends {} = {}> = ((match: string[], context: Readonly<RuleContext<Theme>>) => Awaitable<CSSObject | CSSEntries | string | undefined>);
declare type DynamicRule<Theme extends {} = {}> = [RegExp, DynamicMatcher<Theme>] | [RegExp, DynamicMatcher<Theme>, RuleMeta];
declare type StaticRule = [string, CSSObject | CSSEntries] | [string, CSSObject | CSSEntries, RuleMeta];
declare type Rule<Theme extends {} = {}> = DynamicRule<Theme> | StaticRule;
declare type DynamicShortcutMatcher<Theme extends {} = {}> = ((match: string[], context: Readonly<RuleContext<Theme>>) => (string | string[] | undefined));
declare type StaticShortcut = [string, string | string[]] | [string, string | string[], RuleMeta];
declare type StaticShortcutMap = Record<string, string | string[]>;
declare type DynamicShortcut<Theme extends {} = {}> = [RegExp, DynamicShortcutMatcher<Theme>] | [RegExp, DynamicShortcutMatcher<Theme>, RuleMeta];
declare type UserShortcuts<Theme extends {} = {}> = StaticShortcutMap | (StaticShortcut | DynamicShortcut<Theme> | StaticShortcutMap)[];
declare type Shortcut<Theme extends {} = {}> = StaticShortcut | DynamicShortcut<Theme>;
interface Preflight {
    getCSS: () => string | undefined;
    layer?: string;
}
declare type BlocklistRule = string | RegExp;
interface VariantHandler {
    /**
     * The result rewritten selector for the next round of matching
     */
    matcher: string;
    /**
     * Rewrite the output selector. Often be used to append pesudo classes or parents.
     */
    selector?: (input: string) => string | undefined;
    /**
     * Rewrite the output css body. The input come in [key,value][] pairs.
     */
    body?: (body: CSSEntries) => CSSEntries | undefined;
    /**
     * Provide a parent selector(e.g. media query) to the output css.
     */
    parent?: string | [string, number] | undefined;
}
declare type VariantFunction<Theme extends {} = {}> = (matcher: string, raw: string, theme: Theme) => string | VariantHandler | undefined;
declare type VariantObject<Theme extends {} = {}> = {
    /**
     * The entry function to match and rewrite the selector for futher processing.
     */
    match: VariantFunction<Theme>;
    /**
     * Allows this variant to be used more than once in matching a single rule
     *
     * @default false
     */
    multiPass?: boolean;
};
declare type Variant<Theme extends {} = {}> = VariantFunction<Theme> | VariantObject<Theme>;
interface ConfigBase<Theme extends {} = {}> {
    /**
     * Rules to generate CSS utilities
     */
    rules?: Rule[];
    /**
     * Variants that preprocess the selectors,
     * having the ability to rewrite the CSS object.
     */
    variants?: Variant[];
    /**
     * Similar to Windi CSS's shortcuts,
     * allows you have create new utilities by combining existing ones.
     */
    shortcuts?: UserShortcuts;
    /**
     * Rules to exclude the selectors for your design system (to narrow down the possibilities).
     * Combining `warnExcluded` options it can also helps you identify wrong usages.
     */
    blocklist?: BlocklistRule[];
    /**
     * Utilities that always been included
     */
    safelist?: string[];
    /**
     * Extractors to handle the source file and outputs possible classes/selectors
     * Can be language-aware.
     */
    extractors?: Extractor[];
    /**
     * Raw CSS injections.
     */
    preflights?: Preflight[];
    /**
     * Theme object for shared configuration between rules
     */
    theme?: Theme;
    /**
     * Layer orders. Default to 0.
     */
    layers?: Record<string, number>;
    /**
     * Custom function to sort layers.
     */
    sortLayers?: (layers: string[]) => string[];
}
interface Preset<Theme extends {} = {}> extends ConfigBase<Theme> {
    name: string;
    enforce?: 'pre' | 'post';
}
interface GeneratorOptions {
    /**
     * Merge utilities with the exact same body to save the file size
     *
     * @default true
     */
    mergeSelectors?: boolean;
    /**
     * Emit warning when matched selectors are presented in blocklist
     *
     * @default true
     */
    warnBlocked?: boolean;
}
interface UserOnlyOptions<Theme extends {} = {}> {
    /**
     * The theme object, will be merged with the theme provides by presets
     */
    theme?: Theme;
    /**
     * Preprocess the incoming utilities, return falsy value to exclude
     */
    preprocess?: (matcher: string) => string | undefined;
    /**
     * Layout name of shortcuts
     *
     * @default 'shortcuts'
     */
    shortcutsLayer?: string;
    /**
     * Presets
     */
    presets?: Preset[];
    /**
     * Environment mode
     *
     * @default 'build'
     */
    envMode?: 'dev' | 'build';
}
interface UserConfig<Theme extends {} = {}> extends ConfigBase<Theme>, UserOnlyOptions<Theme>, GeneratorOptions {
}
interface UserConfigDefaults<Theme extends {} = {}> extends ConfigBase<Theme>, UserOnlyOptions<Theme> {
}
interface ResolvedConfig extends Omit<PartialByKeys<Required<UserConfig>, 'preprocess'>, 'rules' | 'shortcuts'> {
    shortcuts: Shortcut[];
    variants: VariantObject[];
    rulesSize: number;
    rulesDynamic: (DynamicRule | undefined)[];
    rulesStaticMap: Record<string, [number, CSSObject | CSSEntries, RuleMeta | undefined] | undefined>;
}
interface GenerateResult {
    css: string;
    layers: string[];
    getLayer(name?: string): string | undefined;
    getLayers(includes?: string[], excludes?: string[]): string;
    matched: Set<string>;
}
declare type VariantMatchedResult = readonly [
    raw: string,
    current: string,
    variants: VariantHandler[]
];
declare type ParsedUtil = readonly [
    index: number,
    raw: string,
    entries: CSSEntries,
    meta: RuleMeta | undefined,
    variants: VariantHandler[]
];
declare type RawUtil = readonly [
    index: number,
    rawCSS: string,
    meta: RuleMeta | undefined
];
declare type StringifiedUtil = readonly [
    index: number,
    selector: string | undefined,
    body: string,
    parent: string | undefined,
    meta: RuleMeta | undefined
];
interface GenerateOptions {
    /**
     * Filepath of the file being processed.
     */
    id?: string;
    /**
     * Generate preflights (if defined)
     *
     * @default true
     */
    preflights?: boolean;
    /**
     * Includes safelist
     */
    safelist?: boolean;
    /**
     * Genreate minified CSS
     * @default false
     */
    minify?: boolean;
    /**
     * @expiremental
     */
    scope?: string;
}

declare function escapeRegExp(string: string): string;
/**
 * CSS Selector Escape
 */
declare function escapeSelector(str: string): string;
declare const e: typeof escapeSelector;

declare function entriesToCss(arr?: CSSEntries): string;
declare function isObject(item: any): item is Record<string, any>;
declare function mergeDeep<T>(original: T, patch: DeepPartial<T>): T;
declare function isStaticRule(rule: Rule): rule is StaticRule;
declare function isStaticShortcut(sc: Shortcut): sc is StaticShortcut;

declare function toArray<T>(value?: T | T[]): T[];
declare function uniq<T>(value: T[]): T[];
declare function mergeSet<T>(target: Set<T>, append: Set<T>): Set<T>;

declare function hex2rgba(hex?: string): [number, number, number, number] | [number, number, number] | undefined;

declare const attributifyRE: RegExp;
declare const validateFilterRE: RegExp;
declare function isAttributifySelector(selector: string): RegExpMatchArray | null;
declare function isValidSelector(selector?: string): selector is string;
declare function normalizeVariant(variant: Variant): VariantObject;
declare function isRawUtil(util: ParsedUtil | RawUtil | StringifiedUtil): util is RawUtil;

declare class TwoKeyMap<K1, K2, V> {
    _map: Map<K1, Map<K2, V>>;
    get(key1: K1, key2: K2): V | undefined;
    getFallback(key1: K1, key2: K2, fallback: V): V;
    set(key1: K1, key2: K2, value: V): this;
    has(key1: K1, key2: K2): boolean | undefined;
    delete(key1: K1, key2: K2): boolean;
    deleteTop(key1: K1): boolean;
    map<T>(fn: (v: V, k1: K1, k2: K2) => T): T[];
}
declare class BetterMap<K, V> extends Map<K, V> {
    map<R>(mapFn: (value: V, key: K) => R): R[];
}

declare function withLayer<T>(layer: string, rules: Rule<T>[]): Rule<T>[];

declare const extractorSplit: Extractor;

export { ArgumentType, Awaitable, BetterMap, BlocklistRule, CSSEntries, CSSObject, ConfigBase, DeepPartial, DynamicMatcher, DynamicRule, DynamicShortcut, DynamicShortcutMatcher, Extractor, ExtractorContext, FlatObjectTuple, GenerateOptions, GenerateResult, GeneratorOptions, ParsedUtil, PartialByKeys, Preflight, Preset, RawUtil, ResolvedConfig, RestArgs, Rule, RuleContext, RuleMeta, Shift, Shortcut, StaticRule, StaticShortcut, StaticShortcutMap, StringifiedUtil, TwoKeyMap, UnoGenerator, UserConfig, UserConfigDefaults, UserOnlyOptions, UserShortcuts, Variant, VariantFunction, VariantHandler, VariantMatchedResult, VariantObject, attributifyRE, createGenerator, e, entriesToCss, escapeRegExp, escapeSelector, extractorSplit, hasScopePlaceholder, hex2rgba, isAttributifySelector, isObject, isRawUtil, isStaticRule, isStaticShortcut, isValidSelector, mergeDeep, mergeSet, normalizeVariant, toArray, uniq, validateFilterRE, withLayer };
