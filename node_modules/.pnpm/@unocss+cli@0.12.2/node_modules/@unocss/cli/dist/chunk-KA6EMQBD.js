"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};

// src/index.ts
var _promises = require('fs/promises');
var _pathe = require('pathe');
var _fastglob = require('fast-glob'); var _fastglob2 = _interopRequireDefault(_fastglob);
var _consola = require('consola'); var _consola2 = _interopRequireDefault(_consola);
var _colorette = require('colorette');
var _core = require('@unocss/core');
var _config = require('@unocss/config');

// package.json
var version = "0.12.2";

// src/errors.ts

var PrettyError = class extends Error {
  constructor(message) {
    super(message);
    this.name = this.constructor.name;
    if (typeof Error.captureStackTrace === "function")
      Error.captureStackTrace(this, this.constructor);
    else
      this.stack = new Error(message).stack;
  }
};
function handleError(error) {
  if (error instanceof PrettyError)
    _consola2.default.error(error.message);
  process.exitCode = 1;
}

// src/utils.ts
function debouncePromise(fn, delay, onError) {
  let timeout;
  let promiseInFly;
  let callbackPending;
  return function debounced(...args) {
    if (promiseInFly) {
      callbackPending = () => {
        debounced(...args);
        callbackPending = void 0;
      };
    } else {
      if (timeout)
        clearTimeout(timeout);
      timeout = setTimeout(() => {
        timeout = void 0;
        promiseInFly = fn(...args).catch(onError).finally(() => {
          promiseInFly = void 0;
          if (callbackPending)
            callbackPending();
        });
      }, delay);
    }
  };
}

// src/config.ts
var _presetuno = require('@unocss/preset-uno'); var _presetuno2 = _interopRequireDefault(_presetuno);
var defaultConfig = {
  envMode: "build",
  presets: [
    _presetuno2.default.call(void 0, )
  ]
};

// src/index.ts
var name = "unocss";
var uno;
var fileCache = new Map();
async function generate(options) {
  var _a;
  const outFile = (_a = options.outFile) != null ? _a : _pathe.resolve.call(void 0, process.cwd(), "uno.css");
  const { css, matched } = await uno.generate([...fileCache].join("\n"));
  await _promises.writeFile.call(void 0, outFile, css, "utf-8");
  if (!options.watch) {
    _consola2.default.success(`${[...matched].length} utilities generated to ${_colorette.cyan.call(void 0, _pathe.relative.call(void 0, process.cwd(), outFile))}
`);
  }
}
async function resolveOptions(options) {
  var _a;
  if (!((_a = options.patterns) == null ? void 0 : _a.length)) {
    throw new PrettyError(`No glob patterns, try ${_colorette.cyan.call(void 0, `${name} <path/to/**/*>`)}`);
  }
  return options;
}
async function build(_options) {
  const options = await resolveOptions(_options);
  const { filepath, config } = _config.loadConfig.call(void 0, );
  uno = _core.createGenerator.call(void 0, config, defaultConfig);
  const files = await _fastglob2.default.call(void 0, options.patterns);
  await Promise.all(files.map(async (file) => {
    fileCache.set(file, await _promises.readFile.call(void 0, file, "utf8"));
  }));
  _consola2.default.log(_colorette.green.call(void 0, `${name} v${version}`));
  _consola2.default.start(`UnoCSS ${options.watch ? "in watch mode..." : "for production..."}`);
  const debouncedBuild = debouncePromise(async () => {
    generate(options);
  }, 100, handleError);
  const startWatcher = async () => {
    if (!options.watch)
      return;
    const { watch } = await Promise.resolve().then(() => require("chokidar"));
    const { patterns } = options;
    const ignored = ["**/{.git,node_modules}/**"];
    _consola2.default.info(`Watching for changes in ${_colorette.cyan.call(void 0, Array.isArray(patterns) ? patterns.join(_colorette.white.call(void 0, ", ")) : patterns)}`);
    const watcher = watch(patterns, {
      ignoreInitial: true,
      ignorePermissionErrors: true,
      ignored
    });
    if (filepath)
      watcher.add(filepath);
    watcher.on("all", async (type, file) => {
      if (file === filepath) {
        uno.setConfig(_config.loadConfig.call(void 0, filepath).config);
        _consola2.default.info(`${_colorette.cyan.call(void 0, _pathe.basename.call(void 0, file))} changed, setting new config`);
      } else {
        _consola2.default.log(`${_colorette.green.call(void 0, `${type}`)} ${_colorette.white.call(void 0, _colorette.dim.call(void 0, file))}`);
        if (type.startsWith("unlink"))
          fileCache.delete(file);
        else
          fileCache.set(file, await _promises.readFile.call(void 0, file, "utf8"));
      }
      debouncedBuild();
    });
  };
  await generate(options);
  startWatcher();
}








exports.__spreadValues = __spreadValues; exports.version = version; exports.handleError = handleError; exports.generate = generate; exports.resolveOptions = resolveOptions; exports.build = build;
