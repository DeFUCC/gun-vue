(() => {
  if (!needPoly()) {
    return;
  }
  const proto = CanvasRenderingContext2D.prototype;
  const original = proto.drawImage;
  if (!original) {
    console.error("This script requires a basic implementation of drawImage");
    return;
  }
  proto.drawImage = function drawImage(source, x, y) {
    const will_crop = arguments.length === 9;
    if (!will_crop) {
      return original.apply(this, [...arguments]);
    }
    const safe_rect = getSafeRect(...arguments);
    if (isEmptyRect(safe_rect)) {
      return;
    }
    return original.apply(this, safe_rect);
  };
  function needPoly() {
    const ctx = document.createElement("canvas").getContext("2d");
    ctx.fillRect(0, 0, 40, 40);
    ctx.drawImage(ctx.canvas, -40, -40, 80, 80, 50, 50, 20, 20);
    const img = ctx.getImageData(50, 50, 30, 30);
    const data = new Uint32Array(img.data.buffer);
    const colorAt = (x, y) => data[y * img.width + x];
    const transparents = [
      [9, 9],
      [20, 9],
      [9, 20],
      [20, 20]
    ];
    const blacks = [
      [10, 10],
      [19, 10],
      [10, 19],
      [19, 19]
    ];
    return transparents.some(([x, y]) => colorAt(x, y) !== 0) || blacks.some(([x, y]) => colorAt(x, y) === 0);
  }
  function getSafeRect(image, sx, sy, sw, sh, dx, dy, dw, dh) {
    const { width, height } = getSourceDimensions(image);
    if (sw < 0) {
      sx += sw;
      sw = Math.abs(sw);
    }
    if (sh < 0) {
      sy += sh;
      sh = Math.abs(sh);
    }
    if (dw < 0) {
      dx += dw;
      dw = Math.abs(dw);
    }
    if (dh < 0) {
      dy += dh;
      dh = Math.abs(dh);
    }
    const x1 = Math.max(sx, 0);
    const x2 = Math.min(sx + sw, width);
    const y1 = Math.max(sy, 0);
    const y2 = Math.min(sy + sh, height);
    const w_ratio = dw / sw;
    const h_ratio = dh / sh;
    return [
      image,
      x1,
      y1,
      x2 - x1,
      y2 - y1,
      sx < 0 ? dx - sx * w_ratio : dx,
      sy < 0 ? dy - sy * h_ratio : dy,
      (x2 - x1) * w_ratio,
      (y2 - y1) * h_ratio
    ];
  }
  function isEmptyRect(args) {
    return [3, 4, 7, 8].some((index) => !args[index]);
  }
  function getSourceDimensions(source) {
    const sourceIs = (type) => {
      const constructor = globalThis[type];
      return constructor && source instanceof constructor;
    };
    if (sourceIs("HTMLImageElement")) {
      return { width: source.naturalWidth, height: source.naturalHeight };
    } else if (sourceIs("HTMLVideoElement")) {
      return { width: source.videoWidth, height: source.videoHeight };
    } else if (sourceIs("SVGImageElement")) {
      throw new TypeError("SVGImageElement isn't yet supported as source image.", "UnsupportedError");
    } else if (sourceIs("HTMLCanvasElement") || sourceIs("ImageBitmap")) {
      return source;
    }
  }
})();
const cache = {};
if (document) {
  class Avatar extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: "open" });
      this.img = document.createElement("img");
      this.shadowRoot.append(this.img);
    }
    render() {
      this.pub = this.hasAttribute("pub") ? this.getAttribute("pub") : "1234123455Ute2tFhdjDQgzR-1234lfSlZxgEZKuquI.2F-j1234434U1234Asj-5lxnECG5TDyuPD8gEiuI123";
      this.size = this.hasAttribute("size") ? this.getAttribute("size") : 400;
      this.round = this.hasAttribute("round") || this.getAttribute("round") == "" ? true : false;
      if (this.round) {
        this.img.style.borderRadius = "100%";
      } else {
        this.img.style.borderRadius = "0%";
      }
      this.dark = this.hasAttribute("dark") || this.getAttribute("dark") == "" ? true : false;
      this.img.src = gunAvatar(this.pub, this.size, this.dark);
    }
    connectedCallback() {
      this.render();
    }
    static get observedAttributes() {
      return ["pub", "round", "size", "dark"];
    }
    attributeChangedCallback(name, oldValue, newValue) {
      this.render();
    }
  }
  customElements.define("gun-avatar", Avatar);
  document.addEventListener("DOMContentLoaded", () => {
    let avatars = document.getElementsByClassName("gun-avatar");
    for (let img of avatars) {
      img.src = gunAvatar(img.dataset.pub, img.dataset.size, img.dataset.dark);
    }
  });
}
function gunAvatar(pub, size = 800, dark = false) {
  var _a;
  if (!pub)
    return;
  if ((_a = cache == null ? void 0 : cache[size]) == null ? void 0 : _a[pub])
    return cache[size][pub];
  const canvas = document.createElement("canvas");
  canvas.width = canvas.height = size;
  const ctx = canvas.getContext("2d");
  const split = pub.split(".");
  const decoded = split.map((single) => decodeUrlSafeBase64(single));
  drawGradient(ctx, decoded[0][42], decoded[1][42], size, dark);
  drawCircles(decoded[0], ctx, size, 0.42 * size);
  ctx.globalCompositeOperation = "lighter";
  drawCircles(decoded[1], ctx, size, 0.125 * size);
  ctx.globalCompositeOperation = "source-over";
  ctx.scale(-1, 1);
  ctx.translate(-size / 2, 0);
  ctx.drawImage(canvas, size / 2, 0, size, size, 0, 0, size, size);
  cache[size] = cache[size] || {};
  cache[size][pub] = canvas.toDataURL();
  return cache[size][pub];
}
function drawGradient(ctx, top, bottom, size, dark = false) {
  var gradient = ctx.createLinearGradient(0, 0, 0, size);
  let offset = 70;
  if (dark)
    offset = 0;
  gradient.addColorStop(0, `hsl(0,0%,${offset + top * 30}%)`);
  gradient.addColorStop(1, `hsl(0,0%,${offset + bottom * 30}%)`);
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, size, size);
}
function drawCircles(data, ctx, size, radius) {
  const chunks = chunkIt(data, 7);
  chunks.forEach((chunk) => {
    if (chunk.length == 7) {
      let x = size / 2 + chunk[0] * size / 2;
      let y = chunk[1] * size;
      let r = chunk[2] * radius;
      let h = chunk[3] * 360;
      let s = chunk[4] * 100;
      let l = chunk[5] * 100;
      let a = chunk[6];
      ctx.beginPath();
      ctx.arc(x, y, r, 0, 2 * Math.PI, false);
      ctx.fillStyle = `hsla(${h},${s}%,${l}%,${a})`;
      ctx.closePath();
      ctx.fill();
    }
  });
}
function decodeUrlSafeBase64(st) {
  const symbols = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
  const symbolArray = symbols.split("");
  let arr = [];
  let i = 0;
  for (let letter of st) {
    arr[i++] = symbolArray.indexOf(letter) / 64;
  }
  return arr;
}
function chunkIt(list, chunkSize = 3) {
  return [...Array(Math.ceil(list.length / chunkSize))].map(() => list.splice(0, chunkSize));
}
export { gunAvatar };
