"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }// src/constants.ts
var MODULE_NAME = "voie-pages";

// src/generator.ts
var _path = require('path'); var _path2 = _interopRequireDefault(_path);

// src/resolver.ts
var _fastglob = require('fast-glob'); var _fastglob2 = _interopRequireDefault(_fastglob);
async function resolve({
  dir,
  extensions,
  exclude
}) {
  return await _fastglob2.default.call(void 0, `${dir}/**/*.{${extensions.join(",")}}`, {
    ignore: ["node_modules", ".git", ...exclude],
    onlyFiles: true
  });
}

// src/routes.ts
var _globtoregexp = require('glob-to-regexp'); var _globtoregexp2 = _interopRequireDefault(_globtoregexp);
function buildRoutes({
  files,
  dir,
  extensions,
  root,
  extendRoute
}) {
  const routes = [];
  for (const file of files) {
    const re = String(_globtoregexp2.default.call(void 0, dir, {extended: true})).slice(1, -2);
    const pathParts = file.replace(new RegExp(re), "").replace(new RegExp(`\\.(${extensions.join("|")})$`), "").split("/").slice(1);
    const component = file.replace(root, "");
    const route = {
      name: "",
      path: "",
      component: component.startsWith("/") ? component : `/${component}`
    };
    let parent = routes;
    for (let i = 0; i < pathParts.length; i++) {
      const part = pathParts[i];
      const isDynamicPart = isDynamicRoute(part);
      const normalizedPart = (isDynamicPart ? part.replace(/^\[(\.{3})?/, "").replace(/\]$/, "") : part).toLowerCase();
      route.name += route.name ? `-${normalizedPart}` : normalizedPart;
      const child = parent.find((parentRoute) => parentRoute.name === route.name);
      if (child) {
        child.children = child.children || [];
        parent = child.children;
        route.path = "";
      } else if (normalizedPart === "index" && !route.path) {
        route.path += "/";
      } else if (normalizedPart !== "index") {
        if (isDynamicPart) {
          route.path += `/:${normalizedPart}`;
          if (/^\[\.{3}/.test(part)) {
            route.path += "(.*)";
          } else if (i === pathParts.length - 1) {
            route.path += "?";
          }
        } else {
          route.path += `/${normalizedPart}`;
        }
      }
    }
    parent.push(route);
  }
  return prepareRoutes(routes, extendRoute);
}
var isDynamicRoute = (s) => /^\[.+\]$/.test(s);
function prepareRoutes(routes, extendRoute, parent) {
  for (const route of routes) {
    if (route.name) {
      route.name = route.name.replace(/-index$/, "");
    }
    if (parent) {
      route.path = route.path.replace(/^\//, "").replace(/\?$/, "");
    }
    if (route.children) {
      delete route.name;
      route.children = prepareRoutes(route.children, extendRoute, route);
    }
    if (typeof extendRoute === "function") {
      Object.assign(route, extendRoute(route, parent) || {});
    }
  }
  return routes;
}
function resolveImportMode(filepath, mode) {
  if (typeof mode === "function") {
    return mode(filepath);
  }
  return mode;
}
function pathToName(filepath) {
  return filepath.replace(/[\_\.\-\\\/]/g, "_").replace(/[\[:\]()]/g, "$");
}
function stringifyRoutes(routes, options) {
  const imports = [];
  const routesCode = routes.map((route) => stringifyRoute(imports, route, options)).join(",\n");
  return `${imports.join(";\n")}

export default [${routesCode}];`.trim();
}
function stringifyRoute(imports, {name, path: path2, component, children, meta}, options) {
  const props = [];
  if (name) {
    props.push(`name: '${name}'`);
  }
  props.push(`path: '${path2}'`);
  props.push("props: true");
  const mode = resolveImportMode(component, options.importMode);
  if (mode === "sync") {
    const importName = pathToName(component);
    imports.push(`import ${importName} from '${component}'`);
    props.push(`component: ${importName}`);
  } else {
    props.push(`component: () => import('${component}')`);
  }
  if (children) {
    props.push(`children: [
      ${children.map((route) => stringifyRoute(imports, route, options))},

    ]`);
  }
  if (meta) {
    props.push(`meta: ${JSON.stringify(meta)}`);
  }
  return `{${props.join(",\n")}}`.trim();
}

// src/generator.ts
async function generateRoutesCode(options) {
  const {root, pagesDir, exclude, extensions, extendRoute} = options;
  const dir = normalizePath(_path2.default.join(root, pagesDir));
  const files = await resolve({dir, extensions, exclude});
  const normalizedRoot = normalizePath(root);
  const routes = buildRoutes({
    files,
    dir,
    extensions,
    root: normalizedRoot,
    extendRoute
  });
  return stringifyRoutes(routes, options);
}
function normalizePath(str) {
  return str.replace(/\\/g, "/");
}

// src/index.ts
function createPlugin(userOptions = {}) {
  const options = {
    root: process.cwd(),
    pagesDir: "src/pages",
    exclude: [],
    extensions: ["vue", "js"],
    importMode: "async",
    extendRoute: (route) => route,
    ...userOptions
  };
  return {
    name: "voie",
    enforce: "pre",
    configResolved(config) {
      options.root = config.root;
    },
    resolveId(source) {
      if (source === MODULE_NAME) {
        return source;
      }
      return null;
    },
    async load(id) {
      if (id === MODULE_NAME) {
        return await generateRoutesCode(options);
      }
      return null;
    }
  };
}
var src_default = createPlugin;


exports.default = src_default;
