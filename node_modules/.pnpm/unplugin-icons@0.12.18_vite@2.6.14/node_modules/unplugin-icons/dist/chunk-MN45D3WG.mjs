import {
  camelize,
  tryInstallPkg,
  warnOnce
} from "./chunk-DFWGO77D.mjs";
import {
  __require,
  __spreadProps,
  __spreadValues,
  __toModule
} from "./chunk-QVRFTMN2.mjs";

// src/index.ts
import { createUnplugin } from "unplugin";

// src/core/options.ts
import { isPackageExists, getPackageInfo } from "local-pkg";
import createDebugger from "debug";
var debug = createDebugger("unplugin-icons:options");
async function resolveOptions(options) {
  const {
    scale = 1.2,
    defaultStyle = "",
    defaultClass = "",
    compiler = await guessCompiler(),
    jsx = guessJSX(),
    customCollections = {},
    autoInstall = false
  } = options;
  const webComponents = Object.assign({
    autoDefine: false,
    iconPrefix: "icon"
  }, options.webComponents);
  debug("compiler", compiler);
  return {
    scale,
    defaultStyle,
    defaultClass,
    customCollections,
    compiler,
    jsx,
    webComponents,
    autoInstall
  };
}
async function guessCompiler() {
  return await getVueVersion() || (isPackageExists("@svgr/core") ? "jsx" : "vue3");
}
function guessJSX() {
  if (isPackageExists("preact"))
    return "preact";
  return "react";
}
async function getVueVersion() {
  try {
    const result = await getPackageInfo("vue");
    if (!result)
      return null;
    return result.version.startsWith("2.") ? "vue2" : "vue3";
  } catch {
    return null;
  }
}

// src/core/loader.ts
import createDebugger4 from "debug";
import { isPackageExists as isPackageExists3 } from "local-pkg";

// src/core/modern.ts
import { promises as fs } from "fs";
import { iconToSVG } from "@iconify/utils/lib/svg/build";
import { defaults as DefaultIconCustomizations } from "@iconify/utils/lib/customisations";
import { getIconData } from "@iconify/utils/lib/icon-set/get-icon";
import createDebugger2 from "debug";
import { isPackageExists as isPackageExists2, resolveModule } from "local-pkg";
var debug2 = createDebugger2("unplugin-icons:icon");
var debugModern = createDebugger2("unplugin-icons:modern");
var debugLegacy = createDebugger2("unplugin-icons:legacy");
var _collections = {};
var isLegacyExists = isPackageExists2("@iconify/json");
async function loadCollection(name, autoInstall = false) {
  if (!_collections[name])
    _collections[name] = task();
  return _collections[name];
  async function task() {
    let jsonPath = resolveModule(`@iconify-json/${name}/icons.json`);
    if (jsonPath)
      debugModern(name);
    if (!jsonPath && isLegacyExists) {
      jsonPath = resolveModule(`@iconify/json/json/${name}.json`);
      if (jsonPath)
        debugLegacy(name);
    }
    if (!jsonPath && !isLegacyExists && autoInstall) {
      await tryInstallPkg(`@iconify-json/${name}`);
      jsonPath = resolveModule(`@iconify-json/${name}/icons.json`);
    }
    if (jsonPath) {
      return JSON.parse(await fs.readFile(jsonPath, "utf8"));
    } else {
      debugModern(`failed to load ${name}`);
      return void 0;
    }
  }
}
function searchForIcon(iconSet, collection, ids, options) {
  var _a;
  let iconData;
  for (const id of ids) {
    iconData = getIconData(iconSet, id, true);
    if (iconData) {
      debug2(`${collection}:${id}`);
      const scale = (_a = options == null ? void 0 : options.scale) != null ? _a : 1;
      const { attributes, body } = iconToSVG(iconData, __spreadProps(__spreadValues({}, DefaultIconCustomizations), {
        height: `${scale}em`,
        width: `${scale}em`
      }));
      return `<svg ${Object.entries(attributes).map((i) => `${i[0]}="${i[1]}"`).join(" ")}>${body}</svg>`;
    }
  }
  return null;
}

// src/core/compilers/jsx.ts
import { importModule } from "local-pkg";
var JSXCompiler = async (svg, collection, icon, options) => {
  const svgr = (await importModule("@svgr/core")).default;
  let res = await svgr(svg, {}, { componentName: camelize(`${collection}-${icon}`) });
  if (options.jsx !== "react")
    res = res.replace('import * as React from "react";', "");
  return res;
};

// src/core/compilers/marko.ts
var MarkoCompiler = (svg) => {
  const openTagEnd = svg.indexOf(">", svg.indexOf("<svg "));
  const closeTagStart = svg.lastIndexOf("</svg");
  const openTag = `${svg.slice(0, openTagEnd)} ...input>`;
  const content = `$!{\`${escapeTemplateLiteral(svg.slice(openTagEnd + 1, closeTagStart))}\`}`;
  const closeTag = svg.slice(closeTagStart);
  return `${openTag}${content}${closeTag}`;
};
function escapeTemplateLiteral(str) {
  return str.replace(/\\.|[$`]/g, (m) => {
    switch (m) {
      case "$":
        return "&#36";
      case "`":
        return "&#96;";
      default:
        return m;
    }
  });
}

// src/core/compilers/none.ts
var NoneCompiler = (svg) => {
  return svg;
};

// src/core/compilers/raw.ts
var RawCompiler = (svg) => {
  return `export default ${JSON.stringify(svg)}`;
};

// src/core/compilers/solid.ts
var SolidCompiler = (svg) => {
  const svgWithProps = svg.replace(/([{}])/g, "{'$1'}").replace(/(?<=<svg.*?)(>)/i, "{...props}>");
  return `export default (props = {}) => ${svgWithProps}`;
};

// src/core/compilers/svelte.ts
var SvelteCompiler = (svg) => {
  const openTagEnd = svg.indexOf(">", svg.indexOf("<svg "));
  const closeTagStart = svg.lastIndexOf("</svg");
  const openTag = `${svg.slice(0, openTagEnd)} {...$$props}>`;
  const content = `{@html \`${escapeSvelte(svg.slice(openTagEnd + 1, closeTagStart))}\`}`;
  const closeTag = svg.slice(closeTagStart);
  return `${openTag}${content}${closeTag}`;
};
function escapeSvelte(str) {
  return str.replace(/{/g, "&#123;").replace(/}/g, "&#125;").replace(/`/g, "&#96;").replace(/\\([trn])/g, " ");
}

// src/core/compilers/vue2.ts
var Vue2Compiler = async (svg, collection, icon) => {
  const { compile } = await Promise.resolve().then(() => __toModule(__require("vue-template-compiler")));
  const transpile = (await Promise.resolve().then(() => __toModule(__require("vue-template-es2015-compiler")))).default;
  const { render } = compile(svg);
  const toFunction = (code2) => {
    return `function () {${code2}}`;
  };
  let code = transpile(`var __render__ = ${toFunction(render)}
`, {});
  code = code.replace(/\s__(render|staticRenderFns)__\s/g, " $1 ");
  code += `
/* vite-plugin-components disabled */
export default {
  render: render,
  name: '${collection}-${icon}',
}
`;
  return code;
};

// src/core/svgId.ts
var randIdFn = "const __randId = () => Math.random().toString(36).substr(2, 10);";
function handleSVGId(svg) {
  const hasID = /="url\(#/.test(svg);
  const idMap = {};
  let injectScripts = "";
  if (hasID) {
    svg = svg.replace(/\b([\w-]+?)="url\(#(.+?)\)"/g, (_, s, id) => {
      idMap[id] = `'${id}':'uicons-'+__randId()`;
      return `:${s}="'url(#'+idMap['${id}']+')'"`;
    }).replace(/\bid="(.+?)"/g, (full, id) => {
      if (idMap[id])
        return `:id="idMap['${id}']"`;
      return full;
    });
    injectScripts = `${randIdFn}const idMap = {${Object.values(idMap).join(",")}};`;
  }
  return {
    hasID,
    svg,
    injectScripts
  };
}

// src/core/compilers/vue3.ts
var Vue3Compiler = async (svg, collection, icon) => {
  const { compileTemplate } = await Promise.resolve().then(() => __toModule(__require("@vue/compiler-sfc")));
  const { injectScripts, svg: handled } = handleSVGId(svg);
  let { code } = compileTemplate({
    source: handled,
    id: `${collection}:${icon}`,
    filename: `${collection}-${icon}.vue`
  });
  code = code.replace(/^export /g, "");
  code += `

export default { name: '${collection}-${icon}', render${injectScripts ? `, data() {${injectScripts};return { idMap }}` : ""} }`;
  code += "\n/* vite-plugin-components disabled */";
  return code;
};

// src/core/compilers/web-components.ts
var WebComponentsCompiler = (svg, collection, icon, { webComponents: options }) => {
  let id = `${collection}-${icon}`;
  if (options.iconPrefix)
    id = `${options.iconPrefix}-${id}`;
  const name = camelize(id);
  return `
export default class ${name} extends HTMLElement {
  constructor() {
    super()
    this.innerHTML = ${JSON.stringify(svg)}
  }
}
${options.autoDefine ? `customElements.define('${id}', ${name})` : ""}
`;
};

// src/core/compilers/index.ts
var compilers = {
  "vue2": Vue2Compiler,
  "vue3": Vue3Compiler,
  "solid": SolidCompiler,
  "svelte": SvelteCompiler,
  "jsx": JSXCompiler,
  "marko": MarkoCompiler,
  "none": NoneCompiler,
  "raw": RawCompiler,
  "web-components": WebComponentsCompiler
};

// src/core/custom.ts
import createDebugger3 from "debug";
var debug3 = createDebugger3("unplugin-icons:custom");
async function getCustomIcon(custom, collection, icon, options) {
  let result;
  debug3(`${collection}:${icon}`);
  if (typeof custom === "function") {
    result = await custom(icon);
  } else {
    const inline = custom[icon];
    result = typeof inline === "function" ? await inline() : inline;
  }
  const scale = (options == null ? void 0 : options.scale) || 1;
  if (result) {
    if (!result.startsWith("<svg "))
      console.warn(`Custom icon "${icon}" in "${collection}" is not a valid SVG`);
    return result.replace("<svg ", `<svg height="${scale}em" width="${scale}em" `);
  }
}

// src/core/loader.ts
var debug4 = createDebugger4("unplugin-icons:load");
var URL_PREFIXES = ["/~icons/", "~icons/", "virtual:icons/", "virtual/icons/"];
var iconPathRE = new RegExp(`${URL_PREFIXES.map((v) => `^${v}`).join("|")}`);
function isIconPath(path) {
  return iconPathRE.test(path);
}
function normalizeIconPath(path) {
  return path.replace(iconPathRE, URL_PREFIXES[0]);
}
function resolveIconsPath(path) {
  if (!isIconPath(path))
    return null;
  path = path.replace(iconPathRE, "");
  const query = {};
  const queryIndex = path.indexOf("?");
  if (queryIndex !== -1) {
    const queryRaw = path.slice(queryIndex + 1);
    path = path.slice(0, queryIndex);
    new URLSearchParams(queryRaw).forEach((value, key) => {
      query[value] = key;
    });
  }
  path = path.replace(/\.\w+$/, "");
  const [collection, icon] = path.split("/");
  return {
    collection,
    icon,
    query
  };
}
async function getIcon(collection, icon, options) {
  const custom = options.customCollections[collection];
  if (custom) {
    const result = await getCustomIcon(custom, collection, icon, options);
    if (result)
      return result;
  }
  return await getBuiltinIcon(collection, icon, options);
}
var legacyExists = isPackageExists3("@iconify/json");
async function getBuiltinIcon(collection, icon, options, warn = true) {
  const ids = [
    icon,
    icon.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(),
    icon.replace(/([a-z])(\d+)/g, "$1-$2")
  ];
  const iconSet = await loadCollection(collection, (options == null ? void 0 : options.autoInstall) && !legacyExists);
  if (iconSet)
    return searchForIcon(iconSet, collection, ids, options);
  if (warn)
    warnOnce(`failed to load \`@iconify-json/${collection}\`, have you installed it?`);
  return null;
}
async function generateComponent({ collection, icon }, options) {
  let svg = await getIcon(collection, icon, options);
  if (!svg)
    throw new Error(`Icon \`${collection}:${icon}\` not found`);
  const { defaultStyle, defaultClass } = options;
  if (defaultClass)
    svg = svg.replace("<svg ", `<svg class="${defaultClass}" `);
  if (defaultStyle)
    svg = svg.replace("<svg ", `<svg style="${defaultStyle}" `);
  const compiler = compilers[options.compiler];
  if (!compiler)
    throw new Error(`Unknown compiler: ${options.compiler}`);
  return compiler(svg, collection, icon, options);
}
async function generateComponentFromPath(path, options) {
  const resolved = resolveIconsPath(path);
  if (!resolved)
    return null;
  return generateComponent(resolved, options);
}

// src/index.ts
var unplugin = createUnplugin((options = {}) => {
  const resolved = resolveOptions(options);
  return {
    name: "unplugin-icons",
    enforce: "pre",
    resolveId(id) {
      if (isIconPath(id)) {
        const res = normalizeIconPath(id).replace(/\.\w+$/i, "").replace(/^\//, "");
        switch (options.compiler || "") {
          case "jsx":
            return `${res}.jsx`;
          case "svelte":
            return `${res}.svelte`;
          case "solid":
            return `${res}.tsx`;
          case "marko":
            return `${res}.marko`;
          default:
            return res;
        }
      }
      return null;
    },
    async load(id) {
      const config = await resolved;
      if (isIconPath(id)) {
        const code = await generateComponentFromPath(id, config) || null;
        if (code) {
          return {
            code,
            map: { version: 3, mappings: "", sources: [] }
          };
        }
      }
      return null;
    }
  };
});
var src_default = unplugin;

export {
  src_default
};
