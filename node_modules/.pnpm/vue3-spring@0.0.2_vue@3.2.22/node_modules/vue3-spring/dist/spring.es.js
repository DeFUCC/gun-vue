/**
 * Vue 3 Spring 0.0.2
 * (c) 2020
 * @license MIT
 */
import { reactive, computed, isRef, isReactive, watchEffect } from 'vue';

/**
 * Find the nearest value in array
 * @param arr
 * @param val
 */
function getFarestValue(array, goal) {
    return array.reduce((prev, curr) => Math.abs(curr - goal) > Math.abs(prev - goal) ? curr : prev);
}
/**
 * requestAnimationFrame
 * @param fun
 */
function requestAnimation(fun) {
    return window.requestAnimationFrame(fun);
}
/**
 * requestAnimationFrame
 * @param fun
 */
function cancelAnimation(id) {
    return window.cancelAnimationFrame(id);
}
/**
 * requestAnimationFrame
 * @param fun
 */
function isNumber(value) {
    return typeof value === 'number';
}
/**
 * requestAnimationFrame
 * @param fun
 */
function isObject(value) {
    return typeof value === 'object';
}

const springDefaults = {
    // init value
    from: 0,
    // desired value
    to: 0,
    // spring stiffness, in kg / s^2
    stiffness: 170,
    // damping constant, in kg / s
    damping: 26,
    // spring mass
    mass: 1,
    // initial velocity
    velocity: 0,
    // number of digits to round the values
    // increase the number to increase precision
    precision: 2,
    // display refresh rate
    framesPerSecond: 60,
    // is animation repeated
    isPendulum: false,
};

function springCore(settings) {
    const props = Object.assign(Object.assign({}, springDefaults), settings);
    const state = reactive({
        currentValue: props.from,
        desiredValue: props.to,
        velocity: props.velocity,
    });
    // Non reactive values
    let animationId = 0;
    // Use for pendulum spring
    let lastDesiredValue = props.to;
    const roundingPrecision = Math.pow(10, props.precision);
    const dumpingPrecision = 1 / roundingPrecision;
    const output = computed({
        get: () => roundNumber(state.currentValue),
        set: (val) => {
            if (typeof val !== 'number')
                return;
            state.desiredValue = lastDesiredValue = val;
            animationId = requestAnimation(dumpValue);
        },
    });
    // start action
    if (state.currentValue !== state.desiredValue) {
        animationId = requestAnimation(dumpValue);
    }
    function dumpValue() {
        const { stiffness, damping, mass } = props;
        // check if value is already dumped
        if (isDumped()) {
            // If dumped start animation in reverse direction
            if (props.isPendulum) {
                switchValueDirection();
            }
            else {
                return;
            }
        }
        const springForce = -1 * stiffness * (state.currentValue - state.desiredValue);
        const damperForce = -1 * damping * state.velocity;
        const acceleration = (springForce + damperForce) / mass;
        state.velocity += acceleration / props.framesPerSecond;
        state.currentValue += state.velocity / props.framesPerSecond;
        cancelAnimation(animationId);
        animationId = requestAnimation(dumpValue);
    }
    function isDumped() {
        const velocity = Math.abs(state.velocity);
        const delta = Math.abs(state.currentValue - state.desiredValue);
        return velocity < dumpingPrecision && delta < dumpingPrecision;
    }
    function roundNumber(value) {
        return Math.round(value * roundingPrecision) / roundingPrecision;
    }
    function switchValueDirection() {
        const valuesArray = [props.from, lastDesiredValue];
        state.desiredValue = getFarestValue(valuesArray, state.currentValue);
    }
    return output;
}

function spring(springValue, props) {
    const springConfig = Object.assign({ to: springValue }, props);
    let output;
    // if there is only one value
    if (!springValue || isNumber(springValue)) {
        springConfig.from = isNumber(springConfig.from) ? springConfig.from : 0;
        output = springCore(springConfig);
    }
    // if the passed value is ref
    else if (isRef(springValue)) {
        springConfig.to = springValue.value;
        springConfig.from = isNumber(springConfig.from) ? springConfig.from : 0;
        output = springCore(springConfig);
    }
    // if the sprint has more than one variable
    else if (isObject(springValue)) {
        const keys = Object.keys(springValue);
        if (!keys.length) {
            throw new Error('[spring] can not find any values');
        }
        const springs = keys.reduce((obj, key) => {
            var _a;
            springConfig.to = springValue[key];
            springConfig.from = ((_a = props === null || props === void 0 ? void 0 : props.from) === null || _a === void 0 ? void 0 : _a[key]) || 0;
            obj[key] = springCore(springConfig);
            return obj;
        }, {});
        output = reactive(springs);
    }
    // watch reactive variables changes
    if (isReactive(springValue)) {
        watchEffect(() => {
            Object.entries(springValue).forEach(([key, value]) => {
                output[key] = value;
            });
        });
    }
    else if (isRef(springValue)) {
        watchEffect(() => (output.value = springValue.value));
    }
    return output;
}

var SpringProvider = {
    name: 'SpringProvider',
    props: {
        from: {
            default: () => ({}),
            type: [Object, Number],
        },
        to: {
            default: () => ({}),
            required: true,
            type: [Object, Number],
        },
        // spring stiffness, in kg / s^2
        stiffness: Number,
        // damping constant, in kg / s
        damping: Number,
        // spring mass
        mass: Number,
        // initial velocity
        velocity: Number,
        // number of digits to round the values
        precision: Number,
        // display refresh rate
        framesPerSecond: Number,
        // is animation repeated
        isPendulum: Boolean,
    },
    setup(props, { slots }) {
        const output = spring(props.to, props);
        // if there is only one value should watch effects
        if (isNumber(props.to)) {
            watchEffect(() => (output.value = props.to));
        }
        return () => slots === null || slots === void 0 ? void 0 : slots.default(output);
    },
};

export { SpringProvider, spring };
