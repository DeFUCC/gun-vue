var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));

// src/rollup/index.ts
function getRollupPlugin(factory) {
  return (userOptions) => {
    const meta = {
      framework: "rollup"
    };
    const rawPlugin = factory(userOptions, meta);
    return toRollupPlugin(rawPlugin);
  };
}
function toRollupPlugin(plugin) {
  if (plugin.transform && plugin.transformInclude) {
    const _transform = plugin.transform;
    plugin.transform = function(code, id) {
      if (plugin.transformInclude && !plugin.transformInclude(id)) {
        return null;
      }
      return _transform.call(this, code, id);
    };
  }
  if (plugin.rollup) {
    Object.assign(plugin, plugin.rollup);
  }
  return plugin;
}

// src/vite/index.ts
function getVitePlugin(factory) {
  return (userOptions) => {
    const meta = {
      framework: "vite"
    };
    const rawPlugin = factory(userOptions, meta);
    const plugin = toRollupPlugin(rawPlugin);
    if (rawPlugin.vite) {
      Object.assign(plugin, rawPlugin.vite);
    }
    return plugin;
  };
}

// src/webpack/index.ts
import fs from "fs";
import { fileURLToPath } from "url";
import { resolve, dirname } from "path";
import VirtualModulesPlugin from "webpack-virtual-modules";

// src/webpack/utils.ts
function slash(path) {
  return path.replace(/\\/g, "/");
}
function backSlash(path) {
  return path.replace(/\//g, "\\");
}

// src/webpack/index.ts
var _dirname = typeof __dirname !== "undefined" ? __dirname : dirname(fileURLToPath(import.meta.url));
var TRANSFORM_LOADER = resolve(_dirname, "webpack/loaders/transform.js");
var LOAD_LOADER = resolve(_dirname, "webpack/loaders/load.js");
function getWebpackPlugin(factory) {
  return (userOptions) => {
    return {
      apply(compiler) {
        var _a;
        const meta = {
          framework: "webpack",
          webpack: {
            compiler
          }
        };
        const virtualModulePrefix = resolve(process.cwd(), "_virtual_");
        const rawPlugin = factory(userOptions, meta);
        const plugin = Object.assign(rawPlugin, {
          __unpluginMeta: meta,
          __virtualModulePrefix: virtualModulePrefix
        });
        const injected = compiler.$unpluginContext || {};
        compiler.$unpluginContext = injected;
        injected[plugin.name] = plugin;
        compiler.hooks.thisCompilation.tap(plugin.name, (compilation) => {
          compilation.hooks.childCompiler.tap(plugin.name, (childCompiler) => {
            childCompiler.$unpluginContext = injected;
          });
        });
        if (plugin.transform) {
          compiler.options.module.rules.push({
            include(id) {
              if (id == null) {
                return false;
              }
              if (plugin.transformInclude) {
                return plugin.transformInclude(id);
              } else {
                return true;
              }
            },
            enforce: plugin.enforce,
            use: [{
              loader: TRANSFORM_LOADER,
              options: {
                unpluginName: plugin.name
              }
            }]
          });
        }
        if (plugin.resolveId) {
          let vfs = compiler.options.plugins.find((i) => i instanceof VirtualModulesPlugin);
          if (!vfs) {
            vfs = new VirtualModulesPlugin();
            compiler.options.plugins.push(vfs);
          }
          plugin.__vfsModules = new Set();
          plugin.__vfs = vfs;
          const resolver = {
            apply(resolver2) {
              const target = resolver2.ensureHook("resolve");
              const tap = () => async (request, resolveContext, callback) => {
                if (!request.request) {
                  return callback();
                }
                const id = backSlash(request.request);
                if (id.startsWith(plugin.__virtualModulePrefix)) {
                  return callback();
                }
                const result = await plugin.resolveId(slash(id));
                if (result == null) {
                  return callback();
                }
                let resolved = typeof result === "string" ? result : result.id;
                if (!fs.existsSync(resolved)) {
                  resolved = plugin.__virtualModulePrefix + id;
                  plugin.__vfs.writeModule(resolved, "");
                  plugin.__vfsModules.add(resolved);
                }
                const newRequest = __spreadProps(__spreadValues({}, request), {
                  request: resolved
                });
                resolver2.doResolve(target, newRequest, null, resolveContext, callback);
              };
              resolver2.getHook("resolve").tapAsync("unplugin", tap());
            }
          };
          compiler.options.resolve.plugins = compiler.options.resolve.plugins || [];
          compiler.options.resolve.plugins.push(resolver);
        }
        if (plugin.load && plugin.__vfsModules) {
          compiler.options.module.rules.push({
            include(id) {
              return id != null && plugin.__vfsModules.has(id);
            },
            enforce: plugin.enforce,
            use: [{
              loader: LOAD_LOADER,
              options: {
                unpluginName: plugin.name
              }
            }]
          });
        }
        if (plugin.webpack) {
          plugin.webpack(compiler);
        }
        (_a = plugin.buildStart) == null ? void 0 : _a.call(plugin);
        if (plugin.buildEnd) {
          compiler.hooks.done.tapPromise(plugin.name, async () => {
            await plugin.buildEnd();
          });
        }
      }
    };
  };
}

// src/define.ts
function createUnplugin(factory) {
  return {
    get rollup() {
      return getRollupPlugin(factory);
    },
    get vite() {
      return getVitePlugin(factory);
    },
    get webpack() {
      return getWebpackPlugin(factory);
    },
    get raw() {
      return factory;
    }
  };
}
export {
  createUnplugin
};
