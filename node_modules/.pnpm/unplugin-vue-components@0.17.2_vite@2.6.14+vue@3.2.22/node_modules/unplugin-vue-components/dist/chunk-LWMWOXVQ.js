"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }


var _chunk7T67WII5js = require('./chunk-7T67WII5.js');

// src/core/utils.ts
_chunk7T67WII5js.init_cjs_shims.call(void 0, );
var _path = require('path');
var _minimatch = require('minimatch'); var _minimatch2 = _interopRequireDefault(_minimatch);
var _resolve = require('resolve'); var _resolve2 = _interopRequireDefault(_resolve);
var _utils = require('@antfu/utils');

// src/core/constants.ts
_chunk7T67WII5js.init_cjs_shims.call(void 0, );
var DISABLE_COMMENT = "/* unplugin-vue-components disabled */";

// src/core/utils.ts
function pascalCase(str) {
  return capitalize(camelCase(str));
}
function camelCase(str) {
  return str.replace(/-(\w)/g, (_, c) => c ? c.toUpperCase() : "");
}
function kebabCase(key) {
  const result = key.replace(/([A-Z])/g, " $1").trim();
  return result.split(" ").join("-").toLowerCase();
}
function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
function parseId(id) {
  const index = id.indexOf("?");
  if (index < 0) {
    return { path: id, query: {} };
  } else {
    const query = Object.fromEntries(new URLSearchParams(id.slice(index)));
    return {
      path: id.slice(0, index),
      query
    };
  }
}
function isEmpty(value) {
  if (!value || value === null || value === void 0 || Array.isArray(value) && Object.keys(value).length <= 0)
    return true;
  else
    return false;
}
function matchGlobs(filepath, globs) {
  for (const glob of globs) {
    if (_minimatch2.default.call(void 0, _utils.slash.call(void 0, filepath), glob))
      return true;
  }
  return false;
}
function getTransformedPath(path, ctx) {
  if (ctx.options.importPathTransform) {
    const result = ctx.options.importPathTransform(path);
    if (result != null)
      path = result;
  }
  return path;
}
function stringifyImport(info) {
  if (typeof info === "string")
    return `import '${info}'`;
  if (!info.name)
    return `import '${info.path}'`;
  else if (info.importName)
    return `import { ${info.importName} as ${info.name} } from '${info.path}'`;
  else
    return `import ${info.name} from '${info.path}'`;
}
function stringifyComponentImport({ name, path, importName, sideEffects }, ctx) {
  path = getTransformedPath(path, ctx);
  const imports = [
    stringifyImport({ name, path, importName })
  ];
  if (sideEffects)
    _utils.toArray.call(void 0, sideEffects).forEach((i) => imports.push(stringifyImport(i)));
  return imports.join(";");
}
function getNameFromFilePath(filePath, options) {
  const { resolvedDirs, directoryAsNamespace, globalNamespaces } = options;
  const parsedFilePath = _path.parse.call(void 0, _utils.slash.call(void 0, filePath));
  let strippedPath = "";
  for (const dir of resolvedDirs) {
    if (parsedFilePath.dir.startsWith(dir)) {
      strippedPath = parsedFilePath.dir.slice(dir.length);
      break;
    }
  }
  let folders = strippedPath.slice(1).split("/").filter(Boolean);
  let filename = parsedFilePath.name;
  if (filename === "index" && !directoryAsNamespace) {
    filename = `${folders.slice(-1)[0]}`;
    return filename;
  }
  if (directoryAsNamespace) {
    if (globalNamespaces.some((name) => folders.includes(name)))
      folders = folders.filter((f) => !globalNamespaces.includes(f));
    if (filename.toLowerCase() === "index")
      filename = "";
    if (!isEmpty(folders)) {
      filename = [...folders, filename].filter(Boolean).join("-");
    }
    return filename;
  }
  return filename;
}
function resolveAlias(filepath, alias = []) {
  const result = filepath;
  if (Array.isArray(alias)) {
    for (const { find, replacement } of alias)
      result.replace(find, replacement);
  }
  return result;
}
function getPkgVersion(pkgName, defaultVersion) {
  try {
    return _chunk7T67WII5js.__require.call(void 0, `${pkgName}/package.json`).version;
  } catch (err) {
    console.error(err);
    return defaultVersion;
  }
}
function shouldTransform(code) {
  if (code.includes(DISABLE_COMMENT))
    return false;
  return true;
}
function resolveImportPath(importName) {
  return _resolve2.default.sync(importName, {
    preserveSymlinks: false
  });
}

// src/core/helpers/libraryResolver.ts
_chunk7T67WII5js.init_cjs_shims.call(void 0, );
var _fs = require('fs'); var _fs2 = _interopRequireDefault(_fs);

var _debug = require('debug'); var _debug2 = _interopRequireDefault(_debug);
var debug = _debug2.default.call(void 0, "unplugin-vue-components:helper:library");
function tryLoadVeturTags(name) {
  var _a;
  try {
    const pkgPath = resolveImportPath(`${name}/package.json`);
    if (!pkgPath)
      return;
    const pkg = JSON.parse(_fs2.default.readFileSync(pkgPath, "utf-8"));
    const tagsPath = (_a = pkg == null ? void 0 : pkg.vetur) == null ? void 0 : _a.tags;
    if (!tagsPath)
      return;
    const tags = JSON.parse(_fs2.default.readFileSync(_path.join.call(void 0, _path.dirname.call(void 0, pkgPath), tagsPath), "utf-8"));
    return Object.keys(tags).map((i) => camelCase(i));
  } catch (e) {
    console.error(e);
  }
}
function LibraryResolver(options) {
  const {
    name: libraryName,
    entries = tryLoadVeturTags(options.name),
    prefix = ""
  } = options;
  if (!entries) {
    console.warn(`[unplugin-vue-components] Failed to load Vetur tags from library "${libraryName}"`);
    return {
      type: "component",
      resolve: () => {
      }
    };
  }
  debug(entries);
  const prefixKebab = kebabCase(prefix);
  const kebabEntries = entries.map((name) => ({ name, kebab: kebabCase(name) }));
  return {
    type: "component",
    resolve: (name) => {
      const kebab = kebabCase(name);
      let componentName = kebab;
      if (prefixKebab) {
        if (!kebab.startsWith(`${prefixKebab}-`))
          return;
        componentName = kebab.slice(prefixKebab.length + 1);
      }
      for (const entry of kebabEntries) {
        if (entry.kebab === componentName)
          return { path: libraryName, importName: entry.name };
      }
    }
  };
}

















exports.DISABLE_COMMENT = DISABLE_COMMENT; exports.pascalCase = pascalCase; exports.camelCase = camelCase; exports.kebabCase = kebabCase; exports.parseId = parseId; exports.matchGlobs = matchGlobs; exports.getTransformedPath = getTransformedPath; exports.stringifyComponentImport = stringifyComponentImport; exports.getNameFromFilePath = getNameFromFilePath; exports.resolveAlias = resolveAlias; exports.getPkgVersion = getPkgVersion; exports.shouldTransform = shouldTransform; exports.resolveImportPath = resolveImportPath; exports.tryLoadVeturTags = tryLoadVeturTags; exports.LibraryResolver = LibraryResolver;
