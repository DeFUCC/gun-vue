import {
  require_gun
} from "./chunk-Y4FTVTXH.js";
import {
  __commonJS
} from "./chunk-LGO6YHUG.js";

// ../../node_modules/.pnpm/gun@0.2020.1235/node_modules/gun/nts.js
var require_nts = __commonJS({
  "../../node_modules/.pnpm/gun@0.2020.1235/node_modules/gun/nts.js"() {
    (function() {
      var Gun = typeof window !== "undefined" ? window.Gun : require_gun();
      var dam = "nts";
      var smooth = 2;
      Gun.on("create", function(root) {
        return;
        var opt = root.opt, mesh = opt.mesh;
        if (!mesh)
          return;
        var connections = [];
        root.on("hi", function(peer) {
          this.to.next(peer);
          connections.push({ peer, latency: 0, offset: 0, next: 0 });
        });
        root.on("bye", function(peer) {
          this.to.next(peer);
          var found = connections.find((connection) => connection.peer.id == peer.id);
          if (!found)
            return;
          connections.splice(connections.indexOf(found), 1);
        });
        function response(msg, connection) {
          var now = Date.now();
          connection.latency = (now - msg.nts[0]) / 2;
          connection.offset = msg.nts[1] + connection.latency - (now + Gun.state.drift);
          console.log(connection.offset);
          Gun.state.drift += connection.offset / (connections.length + smooth);
          console.log(`Update time by local: ${connection.offset} / ${connections.length + smooth}`);
        }
        mesh.hear[dam] = function(msg, peer) {
          console.log("MSG", msg);
          var now = Date.now() + Gun.state.drift;
          var connection = connections.find((connection2) => connection2.peer.id == peer.id);
          if (!connection)
            return;
          if (msg.nts.length >= 2)
            return response(msg, connection);
          mesh.say({ dam, "@": msg["#"], nts: msg.nts.concat(now) }, peer);
          connection.offset = msg.nts[0] + connection.latency - now;
          Gun.state.drift += connection.offset / (connections.length + smooth);
          console.log(`Update time by remote: ${connection.offset} / ${connections.length + smooth}`);
        };
        setTimeout(function trigger() {
          console.log("TRIGGER");
          if (!connections.length)
            return setTimeout(trigger, 100);
          var now = Date.now();
          connections.forEach(function(connection) {
            if (connection.next > now)
              return;
            mesh.say({
              dam,
              "#": String.random(3),
              nts: [now]
            });
          });
          connections.forEach(function(connection) {
            if (connection.next > now)
              return;
            var delay = Math.min(2e4, Math.max(250, 15e4 / Math.abs(connection.offset || 1)));
            connection.next = now + delay;
          });
          var nextRound = Infinity;
          connections.forEach(function(connection) {
            nextRound = Math.min(nextRound, connection.next);
          });
          setTimeout(trigger, nextRound - now);
          console.log(`Next sync round in ${(nextRound - now) / 1e3} seconds`);
        }, 1);
      });
    })();
  }
});

// dep:gun_nts
var gun_nts_default = require_nts();
export {
  gun_nts_default as default
};
//# sourceMappingURL=gun_nts.js.map
